## 一、RPC基础

### 1. 什么是RPC框架？优点是什么？

RPC框架基于RPC协议实现，允许一个程序(称为服务消费者)像调用自己程序的方法一样，调用另一个程序(称为服务提供者)的接口，而不需要了解数据的传输处理过程、底层网络通信的细节等。（RPC 是一种计算机通信协议，是一种用于实现分布式系统中**跨网络通信**的技术。）

RPC的主要优点：

1. 提高性能: RPC 框架通常采用**高效的网络通信协议**和**序列化/反序列化机制**。

2.额外功能: 如负载均衡、服务发现、容错机制等,能提高系统的可靠性、可用性和稳定性。

3.支持动态扩展: 开发者可以动态扩展 RPC 的功能，比如自定义负载均衡器、自定义序列化协议等

### 2. RPC和HTTP的区别？RPC 是计算机哪一层协议？

它们都是**应用层协议**，但是还是有明显的区别。

1. 设计目的
   RPC：用于在分布式系统中实现**远程方法调用**，使得应用程序能够像调用本地方法一样调用远程服务
   HTTP：用于在客户端和服务器之间传输超文本文档，或者在 Web 应用程序之间进行通信。
2. 实现方式
   RPC：通常基于特定的通信协议和编码机制，比如基于 TCP 和自定义协议头实现消息传输，可以提供更高的性能。
   HTTP：基于 TCP 协议，通过请求-响应模型进行通信，采用文本格式的消息头和消息体。
   直截了当地说，HTTP 只是 RPC 框架网络传输的一种可选方式罢了。
3. 使用场景
   RPC 主要用于服务端之间的通信;
   HTTP 主要用于前端和服务器端的通信

### 3. 你了解过哪些 RPC 框架，举一个具体说一说？

常见的 RPC 框架包括 gRPC(Google)、Dubbo(阿里巴巴)、Feign (Netflix基于 HTTP) 等。在我平时的项目中，对 Dubbo 和 Feign 的使用较多

------

## 二、RPC框架的架构设计

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1720756623815-83c0c1ae-eaf7-4597-b0cf-399ec4cf35db.png)

RPC框架需要提供的模块

### 1. 说说完整的RPC调用流程？

1. 服务提供者方启动基于Netty框架的**Web服务器**，并将服务信息注册到本地服务注册器和分布式注册中心Etcd。
2. 服务消费者代理模块从**注册中心**获取到服务提供者的调用信息列表，通过负载均衡算法确定一个调用地址，并构造基于RPC协议的**请求**，然后发起请求，请求消息会经过**编码器**处理。
3. 服务提供者通过**解码器还原**消息，根据消息内容从**本地服务注册器**找到服务实现类，通过**反射**的方式进行调用。
4. 服务提供者将调用结果进行**封装**，通过编码器处理并返回响应消息。服务消费者收到消息后，通过解码器还原消息，从而**完成调用**。
5. 如果某次调用失败了会有容错机制，服务消费端会根据预设好的策略进行**重试**、或者进行故障转移、降级调用别的接口。

### 2. 项目中用到哪些优秀的设计？

1. 健康监测
   健康监测通过定期发送探测请求来检查服务提供者的健康状态。例如，Dubbo支持通过定期的心跳检测来判断服务提供者是否正常工作。如果探测到某个服务提供者不可用，Dubbo会将该服务从注册中心中移除，以防止消费者继续调用已失效的服务。

1. **服务提供者下线了怎么办？
   **失效节点剔除机制

1. 消费端服务缓存

1. **服务消费者每次从注册中心拉取信息，性能会不会很差？
   **用**缓存**优化性能
2. watch机制同步更新

1. 如何优化RPC的通信传输性能**
   **网络框架、自定义协议头、节约传输体积
2. **增加框架扩展性？****
   **SPI机制

### 3. 你在项目中用到了哪些设计模式？举例说明你是如何应用的。

1. 代理模式
   我采用 JDK 动态代理模式实现了消费者对服务提供者的“无感知”调用。消费者通过动态代理实现了对服务提供者的调用，当调用这些代理对象的方法时,实际上是通过网络向远程服务器发送请求，大大简化了远程服务的使用。
2. 工厂模式
   在设计 RPC 框架时,我通过工厂模式实现了序列化器工厂、注册中心工厂、服务代理工厂、负载均衡器工厂、重试策略工厂、容错策略工厂等。通过调用工厂类的方法来获取对象,而不是直接通过 new 操作符创建对象,这种方式降低了调用方和具体类之间的耦合度。
3. 双检锁单例模式
   对于加载指定类型的实例、RPC 配置初始化等操作,我通过对实例进行两次非空的检查和一次对类的Class 对象进行 synchronized 上锁,实现了双检锁单例模式。这样做的好处是在多线程环境下确保只有一个实例被创建，也可以避免在程序启动时就创建实例(按需加载),从而节省了资源并提高了性能。
4. 装饰者模式
   为了解决粘包半包的问题,我使用了 Vert.x 内置 RecordParser 。但由于消息体的长度是不固定的,所以我要通过调整 RecordParser 的固定长度 (变长)来解决,将读取完整的消息拆分为2次,先获取请求体的长度,再根据长度完整读取请求体，
   由于代码较为复杂,我运用了装饰者模式,新写一个 Wrapper 类来实现上述逻辑。使用时只需要用 Wrapper 封装原有 Vert.x 的TCP 处理器,就能解决粘包半包。不用修改原始处理器,使得系统能够更灵活地扩展，代码更利于维护。

------

## 三、注册中心设计（缓存、健康监测、主从复制）

### 注册中心应该实现的基本功能

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724965284925-228dc12c-874e-47d8-a388-e54e5b39afd8.png)

### 键名设计

业务前缀/服务名/服务节点地址

### 1. Etcd如何保证数据一致性？

**Raft** 是一种分布式一致性算法，它确保了分布式系统中的所有节点在任何时间点都能达成一致的数据视图。

写节点

具体来说，Raft算法通过选举机制选举出一个领导者(Leader)节点，领导者负责接收客户端的写请求，并将写操作复制到其他节点上。当客户端发送写请求时，领导者首先将写操作写入自己的日志中，并将写操作的日志条目分发给其他节点，其他节点收到日志后也将其写入自己的日志中。一旦大多数节点(即**半数以上的节点**)都将该日志条目成功写入到自己的日志中，**该日志条目就被视为已提交**，领导者会向客户端发送成功响应，从而保证了数据的一致性。

选主

如果领导者节点宕机或失去联系，Raft算法会在其他节点中选举出新的领导者，从而保证系统的可用性和一致性。新的领导者会继续接收客户端的写请求，并负责将写操作复制到其他节点上，从而保持数据的一致性。

脑裂

无法在剩下的节点中选出领导者，多个节点同时接收写请求，导致数据不一致的结果

### 2. 选用Etcd而不是Zookeeper的理由？

1. **强一致性/顺序性
   **Etcd通过Raft一致性算法保证强一致性，Zookeeper则使用Zab协议保证一致性，Raft的设计让Etcd更容易调试和维护
2. **简单易用
   **Etcd简单易用，提供了简单的API、数据过期机制、数据监听和通知机制，不像Zookeeper需要复杂的设置和文件配置
3. **故障恢复**
   Etcd在领导者故障时能够迅速完成新的领导者选举，减少了系统的不可用时间。

### 3. 说说心跳监测和续期机制？

心跳监测是一种用于监测系统是否正常工作的机制，通过**定期**发送心跳信号来监测目标系统的状态。如果在一定时间内未能正常响应请求，就会认为目标系统故障或不可用，从而触发相应的处理和告警机制。

心跳监测一般需要两个关键：定时、网络请求

但是使用Etcd实现心跳监测就会更简单一点，因为Etcd自带key过期机制，可以给key设置一个过期时间，在**服务提供者端通过CronUtil定期进行续期**，从而重置自己的过期时间。如果节点宕机，一直不续期，Etcd就对过期的key进行删除。

服务提供者端：每个服务提供者都会在本地维护一个**已注册节点集合**，注册时会把节点key添加到集合中，只需要设置定时任务续期集合内的key就行。这种方案还有个好处，假设注册中心数据出现丢失了，心跳检测也会重新注册节点信息。

### 4. 服务节点下线机制？

服务节点下线分为主动下线和被动下线

主动下线：服务提供者项目正常退出时，主动从注册中心移除注册信息。可以用ShutdownHook实现，JVM 的 ShutdownHook是Java 虚拟机提供的一种机制,允许开发者在JVM 即将关闭之前执行一些清理工作或其他必要的操作，例如关闭数据库连接、释放资源、保存临时数据等。

被动下线：服务提供者项目异常退出时，利用Etcd的key过期机制自动移除

### 5. 说说消费端的缓存设计？

正常情况下，服务节点信息列表的更新频率并不高的，所以服务消费者从注册信息拉取列表后，可以把信息缓存在本地，下次就不用从注册中心获取了，能够提高性能。本地缓存的实现用一个列表来存储服务即可，提供操作列表的基本方法，包括：写缓存、读缓存、清空缓存

修改服务发现逻辑，优先从缓存获取服务；如果没有缓存，优先从注册中心获取，并且设置到缓存中

### 6. 你的服务缓存是怎么更新的？

Etcd有一个watch监听机制，它监听的某个key发生修改或删除时，就会触发事件来通知监听者也就是服务消费端。启动watch机制可以通过Etcd的java客户端实现，
在消费端每进行一次RPC调用，拉取服务列表时会对获取到的服务节点key进行监听。

## 四、底层网络通信（序列化、自定义协议、编码解码器）

### 1. 为什么自定义协议而不用HTTP？

HTTP协议是RPC框架网络传输的一种可选方式，但是一般情况下RPC框架比较注重性能，而HTTP是一个文本协议，包含请求响应标头等大量元数据，会增加数据传输的开销。对于需要极低延迟或高吞吐量的系统，HTTP降低系统的性能，使用自定义协议可以减少不必要的元数据传输，从而提高性能。



### 2. 为什么会发生半包问题？粘包问题？

**半包** 是指一次发送的数据包在接收端未能一次性接收完整，数据被分成了多次接收，这种情况就称为半包

<img src="https://cdn.nlark.com/yuque/0/2024/png/42782944/1724974187580-87c331c4-c1fa-4503-8655-197b3c041e1d.png" alt="img" style="zoom: 50%;" />

**粘包** 指发送方连续发送的多个数据包在接收端被合并成一个包接收，这样接收端无法区分出原始的多个独立数据包。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724974270310-732c1ea8-f208-4407-b698-627bc8fc00e8.png)

### 3. 你是怎么解决半包、粘包问题？

我是自定义的协议头，每个包前加上长度字段来明确包的边界，这样接收端可以通过解析这些信息正确地拆分数据包。

### 4. 选择序列化器考虑哪些方面？

1. 更高的性能，速度快不快（**首要**）
2. 更小的序列化结果
3. 处理复杂的数据结构（类方法）和循环引用
4. 跨语言



------

## 

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724367498430-86fdaf02-d5f5-4e15-ae86-87987aa8a457.png)



------

## 五、高可用

### 1. 在项目中如何实现负载均衡算法？

1. **随机法**

如果没有配置权重的话，所有的服务器被访问到的概率都是相同的。如果配置权重的话，权重越高的服务器被访问的概率就越大。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724720654438-a23d614d-b03c-4457-9113-d8b8efb6e7af.png)

1. **轮询**

按照循环的顺序将请求分配给每个服务器。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724721755807-52e48ced-f23f-46bf-a418-1ae62290b6df.png)

1. **一致性Hash**

先说说哈希法，

**哈希法**的原理：将请求的参数信息通过哈希函数转换成一个哈希值，然后根据哈希值决定请求被哪一台服务器处理。在服务器数量不变的情况下，相同的ip地址，也就是同一个请求参数信息最后都被发到同一个服务器处理。

**一致性哈希法**的核心思想是将哈希值空间构建成一个环状结构，每个节点或服务器在环上占据一个位置，每个请求根据其哈希值映射到环上的一个点，然后顺时针找到第一个大于等于该哈希值的节点，将请求路由到该节点上。
![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724721820363-ae2f09a7-144b-4910-aaf5-7ce1ecece918.png)

一致性Hash算法解决了两个痛点问题

1. 节点下线：某个节点下线之后，其负载会被平均分摊到其他节点，不会影响到整个系统的稳定性。反例像「轮询算法」：某个节点下线了，凡是打到该个节点的请求都要收到影响
2. 倾斜问题：通过虚拟机节点引入，将每个物理节点映射到多个虚拟节点上，使得节点在哈希环上的分布更加均匀，减少了节点之间的负载差异。



### 2. 说说容错策略？具体怎么实现的？

分布式系统中各个组件都有可能出现网络故障、节点异常等问题，	

是什么、概念性问题

阐述的时候依旧遵循STAR法则

1. **FailOver 故障转移**：当某一个节点出现故障时，为确保服务不中断，自动切换到备用节点。
2. **FailBack 失败自动恢复**：在主组件恢复后，为了恢复正常运行状态，系统从备用组件切换回主组件。
3. **FailSafe**：在出现故障时，保证系统不会崩溃，系统默认返回一个安全的值或执行一个安全的操作。
4. **FailFast**：在检测到错误，为了避免不必要的操作或进一步的故障传播，立即终止操作，不进行任何重试或切换。

### 3. 注册中心宕机怎么办？