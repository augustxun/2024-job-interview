## 一、登录&&拦截器

### 1. 简述登录逻辑？

登录逻辑可以分为三步。

1. **发送验证码**：用户在提交手机号后，会检验手机号是否合法，不合法会要求重新提交。如果手机号合法，后台会生成对应的验证码，然后再通过短信的方式将验证码发送给用户。
2. **短信验证码登录、注册：**用户将手机号和验证码同时输入，后台拿到验证码后，会与存在 Redis 缓存中的验证码进行比对，如果相等，则根据手机号查询数据库；如果用户不存在，则创建一个新的用户。接着用 UUID生成一个token作为键，User视图对象数据作为值，存到 Redis 当中去，再把这个token 返回给前端。
3. **校验登录状态：** 每次给后端接口发起请求时，会携带token，后台从Redis中取出 token 对应的 value，判断是否存在这个数据，如果没有则进行拦截。如果存在就将其保存到ThreadLocal中并放行。

### 2. 如何实现分布式Session？解决的是什么问题？

我是基于Redis缓存中间件来实现Session共享。当注册完成后，用户去登录会提供手机号和验证码，如果验证码一致，则根据手机号查用户信息，如果不存在则新建，最后将用户数据保存到 Redis，并且生成 token作为 Redis 的Key。当前端需要校验用户是否登录时，会携带 token 进行访问，从 Redis 中取出 token 对应的value，判断是否存在这个数据，如果没有则进行拦截，如果存在就保存到 ThreadLocal 中，并且放行。

------

## 二、分布式锁设计

### 1. Redis实现分布式锁知道吗？

### 2. 为什么用Redisson？

### 3. Redisson底层原理你懂吗？

### 4. 看门狗机制具体怎么实现的？

### 5. redisson如何解决主节点宕机问题（setnx进入master，但是宕机，slave节点还没有收到写命令）

------

## 三、缓存设计

### 1. 布隆过滤器用来过滤哪些流量？

1. 现有商品的id，对于不存在的商品请求直接返回错误
2. 把「商品ID+用户ID」作为单个用户的重复购买记录，避免用户重复下单
3. 恶意用户的id和ip地址

### 2. 布隆过滤器满了怎么办？你是如何保证布隆过滤器和MySQL数据一致性？

1. **多段布隆过滤器**：通过多层次扩展解决容量问题，用一个列表存储所有布隆过滤器，每当上一个满了就创建一个新的更大的布隆过滤器
2. **轮换布隆过滤器**：一般用于应对某个限时活动，设定时间窗口，根据秒杀的时间段分开存储。
3. **计数布隆过滤器**：支持元素删除，每个位置上不用0或1，而是存在时加上1，不存在了就减去1。

在我的业务场景下，布隆过滤器没有去重刷的必要性

### 3. 热点数据失效（缓存击穿）怎么解决的？

***缓存穿透***

缓存穿透的含义是对于将要查询的数据既不在Redis 中，也不在数据库中，大量请求到达数据库造成数据库压力骤增，可能造成数据库宕机。

在本项目中主要使用缓存空值的方式来解决缓存穿透的问题，先从 Redis查询商铺缓存，如果是空值就直接返回，不会再去查询数据库；如果不是空值，则会去根据 id 查询数据库，如果存在则写入 Redis，不存在就写入空值。

### 4. 补货场景下多个数据组件之间数据一致性如何去保证？

「补货」业务背景

首先假定前提是单体架构

更新数据库，缓存和本地标记还没有来得及更新导致数据不同步

可能产生以下问题：

1. 超卖少卖？
2. 缓存击穿/雪崩



一致性目标

允许布隆过滤器、缓存和数据库在短期内数据不完全一致，**但最终它们会达到一致状态**。



解决方案（不限于以下几种	

系统收到补货请求时不会同步完成补货，而是将补货消息放入消息队列，由异步任务执行具体的库存更新操作。补货消息可以包含商品ID、补货数量、补货请求ID

1. 补货顺序：从下往上更新，数据库 -> Redis缓存 -> 布隆过滤器

1. 数据库补货

1. 首先幂等性检查，确保「补货」请求不会被重复处理
2. 接着需要操作数据库添加库存，**扣减库存**和**补货业务**都会在db底层执行update语句，会自动为商品记录加行级锁，避免并发写造成数据覆盖。
3. 如果某个商家批量给多个商品补货，可以把多个update语句放在一个事务里执行，避免发生商品1,3成功，2失败
4. 再把请求ID加入到Redis中代表某次补货已经完成，键为业务名+ID，值为true，保证幂等性

1. Redis补货
   Redis补货并不是简单地把MySQL当前数据写到Redis，而是在Redis的当前库存量上加上补货量

1. 更新完数据库后立即去更新Redis，用lua脚本保证原子性：查询库存量 -> 增加补货量 -> 更新库存

1. 检查本地标记
   补货前商品已经售空：补货后标记值从true改为false
   补货前商品有余量：不执行操作
2. 检查布隆过滤器
   一般布隆过滤器只支持「新增」操作，只要保证补货的商品一直在布隆过滤器中存在就行

1. 异常处理机制

1. 重试：如果某个操作失败了，通过不断重试直到成功
2. 补偿：当某个步骤失败时，将补偿操作消息发送到队列中，异步处理该步骤的失败操作。

1. 对账-定时校验系统：实现一个定时校验系统进行对账，同时对Redis、消息队列、MySQL进行监控，Redis中库存为m，消息队列未被消费的消息数量为n，MySQL库存为k，数据一致性的理想情况是m+n=k。消息队列中待消费消息数量n可以通过在Redis中维护一个计数器实现。

------

## 四、秒杀下单逻辑

### 1. 双十一场景，流量激增做了哪些考虑？

假设有10w个纸巾

1. 令牌桶限流
2. 线程池技术控制瞬时分布
3. Redis主从，主节点负责写，从节点负责读
4. Redis集群，横向扩展Redis实例，把数据进行分片来处理更多的并发请求，每个实例可以保存1w库存

### 2. 主节点挂了怎么办？此时从节点中的数据还没来得及扣减，会导致超卖

1. 使用**同步复制机制**，客户端向主节点发送写请求，等待指定数量的从节点完成数据同步，等待同步完成，同步成功就返回结果，失败就返回错误
2. **半同步复制机制，**用两个参数进行约束
   min-slaves-max-lag：设置从节点允许的最大复制延迟时间，超过这个时间会被认为不符合同步要求
   **min-slaves-to-write**：设置主节点在接受写操作之前，要求至少有指定数量的从节点处于连接状态，并且复制延迟小于设定的阈值
3. 数据持久化：AOF
4. 直接暂停Redis对外服务，这一场少卖一点，下一场多卖一点

### 3. 秒杀中如何解决重复下单问题？

MySQL唯一索引+分布式锁

### 4. 如何解决超卖问题？

问题分析：



方案：MySQL排他锁 + Redis预扣库存

执行update操作时为数据行加了排他锁，这一行就不能被其他的线程修改和读写。

补充：设置数据库字段类型为无符号整数，这样一旦库存为负就会在执行SQL时报错。



1. **缓存预热：**在系统初始化时，将商品以及对应的库存数量预先加载到`Redis`缓存中；比如商品有100件。那么我在redis存储一个k,v。例如 <gs1001, 100>
2. 每一个用户线程进来，值就减1，等减到0的时候，全部拒绝剩下的请求。那么也就是只有100个线程会进入到后续操作，所以一定不会出现超卖的现象。
3. 将请求消息放入**消息队列**中，返回正在排队中；服务端下单业务模块监听消息队列并消费消息，消费成功的可以生成秒杀订单，扣减MySQL数据库库存，通过websocket向用户发送一个秒杀成功通知。前端以此来判断是否秒杀成功，秒杀成功则进入秒杀订单详情，否则秒杀失败。

### 5. 如何解决少卖？

### 6. 你库存扣减之后，还要去创建一个新订单，你是如何保证中间过程一致性？（少卖问题）

问题背景

Redis成功扣减库存，但是「消息队列异步下单」出现问题，消息没有发出去或消息没有成功被消费，从而出现db的库存大于Redis库存。这也就代表出现了“少卖”问题。

在这个业务场景下有几个环节值得重点关注

1. 生产者发布消息到消息队列失败

1. 本地信息表+定时任务重试：将 Redis 库存扣减和消息存储在同一个数据库事务中，确保一致性，并通过定时任务确保消息最终发送成功。
2. 发布确认和重试机制：成功发布后消息队列会回复确认消息，没有得到确认消息生产者需要重试

1. 消息队列故障或宕机

1. 将消息持久化到本地
2. 镜像模式做好数据备份

1. 消费端异常导致消息丢失或重复消费

1. 丢失

1. 使用basicAck确认机制保证消息被成功消费才删除消息队列里的消息，无法被消费的消息就放入到死信队列
2. 对账系统

1. 重复消费：幂等性处理，使用唯一的订单号，插入操作时让其失败

------

## 关注和点赞

### 说说你的数据结构怎么设计的？

### 我关注的人和关注我的人怎么设计的？



### 那种大v，粉丝数量应该很多，这种热key+大key你是怎么处理的？分表知道吗？

rabbitmq进行异步处理？那我假如关注一个人之后，马上要给他发消息怎么办（场景：互关才能发消息），你怎么保证这个即时性？

博客加载：（自己做了个串行加载改并行：thread pool+future）
线程池的参数怎么设计的，核心线程数2n（n=cpu核心数）？但是你多个tomcat请求共用一个线程池啊......tomcat线程池都有几百个线程了，2n肯定不行
future类异步获取加载结果，如果等待时间很长怎么办？一直阻塞吗？







------

## 高可用设计

### 1. 如果 Redis 挂掉怎么办？

1. Redis主从复制与哨兵模式
2. 集群模式
3. 消息队列
   在Redis不可用时，可以先将用户请求写入队列，等Redis恢复后再处理这些请求。
4. 限流与熔断保护

## 数据表设计

### 1. 用到哪些索引？

1. 商品表的id作为默认主键，所以用到主键索引。
   支持商品名称的模糊查询，所以在name字段上添加索引
2. 订单表有一个user_id，为了保证一人一单，需要把user_id作为查询条件，所以添加索引
   为了便于对下单时间进行范围查询，给下单时间建立索引
3. 用户表的email，phone都可以添加唯一索引保证不会重复注册