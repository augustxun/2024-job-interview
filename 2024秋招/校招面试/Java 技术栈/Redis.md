## 一、Redis基础

### 1. **为什么要用缓存？什么是 Redis？**

使用缓存的目的就是在实际的业务场景下，为了有效提升读写性能，一般把 MySQL 中的**热点数据缓存到Redis**。

1. 减轻 MySQL 读写压力；
2. 提升服务端响应速度，优化用户体验。

关于 Redis️

1. Redis 是一种高性能的**基于内存的数据存储系统**，读写操作都是在内存中完成，因此速度快、延迟低。
2. Redis 支持**多种数据结构**，包括字符串、哈希、列表、集合、有序集合等，非常灵活；还提供了一些**高级功能**，如发布订阅、Redis 事务、Lua 脚本等。
3. Redis 支持**将数据持久化到磁盘中**，以保证数据的安全性和可恢复性。
4. Redis 具有**分布式特性**，可以通过分片和赋值来实现高可用和高扩展性。

### 2. (中高频) Redis 为什么快？

1. Redis基于内存，内存的访问速度比磁盘快很多；
2. Redis工作线程是单线程，避免了多线程锁的竞争，上下文切换可能带来时间开销；
3. Redis采用**I/O多路复用机制**处理大量的客户端socket请求，指一个redis线程处理多个IO流。Redis 通过 I/O 多路复用机制（如 select、epoll）向内核注册 socket 的监听事件。当有请求到达时，内核会通知 Redis 来处理该请求。
   这种机制有效地避免了轮询方式的资源浪费，并允许 Redis 的单线程处理大量的并发连接。
4. 并且Redis含有多种高效数据结构

Redis底层执行过程

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725587993641-28a6736e-809a-4c28-bb6a-e862331f7d6a.png)

监听事件的概念

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725735715289-b137ee34-9814-47cd-b9fb-3a4c8c783649.png)

### 3. Redis和Memcached有什么区别？

很多人都说用 Redis 作为缓存，但是 Memcached 也是基于内存的数据库，为什么不选择它作为缓存呢？要解答这个问题，我们就要弄清楚 Redis 和 Memcached 的区别。 Redis 与 Memcached **共同点**：

1. 都是基于内存的数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。

Redis 与 Memcached **区别**：

1. Redis 支持的数据类型更丰富（String、Hash、List、Set、ZSet），而 Memcached 只支持最简单的 key-value 数据类型；
2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用，而 Memcached 没有持久化功能，数据全部存在内存之中，Memcached 重启或者挂掉后，数据就没了；
3. Redis 原生支持集群模式；Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；
4. Redis 支持一些高级功能，发布订阅模型、Lua 脚本、事务等功能；Memcached 没有

### 4. (中高频) Redis和MySQL的区别？

1. Redis 基于内存，MySQL 基于硬盘
2. Redis 是非关系型数据库，MySQL 是关系型数据库
3. 

### 5. 为什么用 Redis 作为缓存中间件？

1. *Redis 具备高性能*

如果用户查询MySQL的数据，磁盘I/O的效率比较低。将该用户访问的数据缓存在Redis中，下一次再访问这些数据的时候就可以直接从缓存中获取，操作 Redis 缓存就是直接操作内存，所以速度相当快。

1. *Redis 具备高并发*

单台设备的Redis的QPS（每秒钟处理完请求的次数）是MySQL的10倍，Redis单机的QPS能轻松破10w，而MySQL单机的QPS很难破1w。

所以，直接访问Redis的请求承载量是远远大于直接访问MySQL的，所以适用于高并发场景。实际开发中，可以考虑提前把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。

1. *功能全面*

Redis 除了用作缓存，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大。

------

## 二、缓存篇

### 1. (高频) 什么是缓存雪崩？缓存击穿？缓存穿透？️

*缓存雪崩*

当**大量缓存数据在同一时间过期**（失效）或者 Redis 故障宕机时，如果此时有大量的用户请求都无法在Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增。后果是可能会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。

*缓存击穿*

缓存中的**某个热点数据过期了**，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是**缓存击穿**的问题。

*缓存穿透*

当用户访问的数据，**既不在缓存中，也不在数据库中**，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据，因此也无法通过数据库构建缓存服务后续的请求。那么当有大量这样的请求到来时，数据库的压力骤增，这就是**缓存穿透**。

### 2. (高频) 缓存雪崩方案？️

应对缓存雪崩解决方案一般取决于发生缓存雪崩的原因。

如果原因是**大量数据同时过期**，一般会采用以下方案：

1. 均匀设置过期时间，在对缓存数据设置过期时间时，**给这些数据的过期时间加上一个随机数**；
2. 互斥锁，如果发现访问的数据在Redis失效了，就加个互斥锁，保证同一时间内只有一个请求来构建缓存；
3. 给缓存设置逻辑过期时间，将更新缓存的工作交由后台线程定时更新；

如果是故障宕机，会采用如下方案：

1. 可以启动**服务熔断机制**，暂停业务应用对缓存服务的访问，直接返回错误。如果想减少对业务的影响，我们可以启用**请求限流**机制，只将少部分请求发送到数据库进行处理，再多的请求就在入口直接拒绝服务；
2. 通过主从节点的方式构建Redis缓存高可用集群。

### 3. (高频) 缓存击穿方案？

缓存击穿问题主要是针对Redis️缓存中的**热点**数据过期问题

- ***互斥锁/分布式锁\***

对于热点数据的查询请求，当Redis中没有数据时，先获取锁再进行查询，然后将数据存入Redis，这样可以避免同一时间多个请求访问数据库。未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回过期的值。

- ***逻辑过期\***

给热点数据设置**逻辑过期时间**，而不是普通过期时间。在热点数据准备要过期前，提前**通知后台线程更新缓存**以及重新设置过期时间；

### 4. (高频) 缓存穿透方案？️

1. ***非法请求的限制\***；在 API 入口处我们要判断1.请求参数是否含有非法值；2.请求字段是否存在，如果判断出是恶意请求就直接返回错误；
2. ***缓存空值或者默认值\***：业务发现缓存穿透的现象时，可以针对查询的数据，在缓存中设置一个空值或者默认值，这样后续请求就可以从缓存中读取到空值或者默认值，返回给应用，而不会继续查询数据库；
3. ***布隆过滤器\***：我们可以在写入数据库数据时，使用布隆过滤器做个标记，然后在用户请求到来时，可以通过查询布隆过滤器快速判断数据是否存在，如果不存在，就不用通过查询缓存或数据库；

### 5. 说说布隆过滤器？️️

布隆过滤器的作用是快速判断一个元素是否在集合中，底层是一个位数组和多个哈希函数组成。它的基本思想是通过多个哈希函数将元素映射到位数组的多个位置，以此来表示集合中的元素。假设位数组长度为 *m，*有 *k* 个独立的哈希函数。

对于要添加的元素，使用 *k* 个哈希函数计算其 *k* 个哈希值。将这些哈希值对 *m* 取模，以得到位数组中的 *k* 个索引，将位数组中这 *k* 个索引位置上的位设置为 1。

对于要查询的元素，同样使用 k 个哈希函数计算其 𝑘 个哈希值，将这些哈希值对 𝑚 取模，以得到位数组中的 𝑘 个索引，检查位数组中这 k 个索引位置上的位是否都为 1。

### 6. 说说对数据一致性的理解？

强一致性确保在任何时间点，无论从哪个节点读取数据，用户看到的都是最新数据。

从Redis中读到的数据和MySQL中读到的数据一样

### 7. (高频) Redis和MySQL的一致性方案？

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1724648959082-c34ba98a-6f8c-4f07-95aa-ca5f801c8a61.png)

在单体系统中，将对缓存与数据库操作放在一个事务中比如用@Transactional注解，分布式系统中利用TCC等分布式事务方案。

### 8. 先更新数据库，还是先删除缓存？️

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1709934333827-dd72eb36-cff8-4363-a51c-de76655014e6.png)

总结：

先删除缓存策略：发生并发安全问题条件为，写操作完成前进行了一项读操作；

先操作数据库策略：发生并发安全问题条件为，读操作完成前进行了一项写操作

### 9. 「先删除缓存，后更新数据库」造成数据不一致的解决方案？️

***延迟双删\***

加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除脏数据缓存。

```plain
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```

### 10. 什么是延时双删？延时双删可能会导致的问题？

### 11. 先更新数据库，后删除缓存，第二步操作失败的解决方案？⭐️

***重试机制\***

我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。

- 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

***订阅 MySQL binlog，再操作缓存\***

「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。

------

## 三、Redis数据结构

### 1. (高频) Redis 数据类型有哪些？️Redis 数据类型使用场景分别是什么？️

- 

Redis 五种数据类型的应用场景：

1. String 类型的应用场景：这是 Redis 最基本的数据类型，它的值可以是字符串，整数，浮点数，序列化的对象，一个键最大能存储 512MB 的数据。
   存对象、常规计数、**分布式锁**、共享 session 信息等。
2. List 类型的应用场景：按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的增删操作非常快。
   消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
3. Hash 类型：一个键值对集合，是 String 类型的 field 和 value 的映射表。它特别适合用于存储对象，可以像数据库中更新一个属性一样只修改某一项属性值
   缓存对象、购物车等。
4. Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
5. Zset 类型：排序场景，比如排行榜、电话和姓名排序等。

Redis 后续版本又支持四种数据类型，它们的应用场景如下：

1. BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
2. HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
3. GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
4. Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。

### 2. 说说压缩列表？优缺点？

- 

压缩列表是 Redis 为了节约内存开发的，它是由连续内存块组成的顺序型数据结构，有点类似于数组。

压缩列表的缺点：

1. 查询效率为 O(n)，元素数量过大时查询效率就会降低；
2. 每个节点保存了前一个节点的长度，当新增或修改某个元素时，压缩列表占用的内存空间需要重新分配，甚至可能引发连锁更新的问题，从而效率下降。

### 3. 跳表？跳表查找和插入的时间复杂度？

Redis 只有 Zset 对象的底层实现用到了跳表，
跳表依靠多层链表实现，最底层的链表包含了所有的元素，上层的链表中间会跳过若干元素，然后用指针相连，在查找时跳跃查找，速度更快

查询平均时间复杂度O(logN)

### 4. String 类型底层实现？

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

1. **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
2. **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
3. **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

### 5. List 类型内部实现

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。

### 6. Hash 类型底层实现？

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；

如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。

### 7. Set 类型底层实现？

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

### 8. (中高频) ZSet是什么？ZSet类型底层实现？

Zset类型相比于Set类型多了一个排序属性score，元素按照score进行有序排列，还可以通过score范围获取元素的列表。Zset底层数据结构是**跳表**加**哈希表**实现：

跳表是ZSet核心结构，用于维持元素的有序性，通过多级链表结构，支持快速的范围查询，时间复杂度是O(logn)

哈希表用于确保集合中每个元素都是唯一的避免重复添加，存储每个成员元素及其对应的分数，哈希表通过元素名称来快速检索其分数，时间复杂度O(1)

------

## 四、Redis 线程模型

### 参考资料

[「JAVA知识每日一问」：Redis6.0为什么引入多线程？](https://bbs.huaweicloud.com/blogs/352734)

[Redis6.0多线程模型总结](https://www.cnblogs.com/jelly12345/p/15136912.html)

### 1. (中高频) Redis 是单线程吗？️

Redis单线程指的是从「接收客户端请求->解析请求 ->进行数据读写等操作->发送数据给客户端」这个过程是由一个主线程来完成。

但是Redis在启动时，会启动后台线程BIO：

1. **Redis在2.6版本**，会启动2个后台线程，分别处理关闭文件、AOF刷盘这两个任务；
2. **Redis在4.0版本之后**，新增了一个新的后台线程，用来异步释放Redis内存，也就是lazyfree线程。例如执行 unlink key / flushdb async / flushall async 等命令，会把这些删除操作交给后台线程来执行，好处是不会导致 Redis 主线程卡顿。
   因此，当我们要删除一个大 key 的时候，不要使用`del`命令删除，因为`del`是在主线程处理的，这样会导致Redis主线程卡顿，因此我们应该使用`unlink`命令来异步删除大key。

### 2. Redis6.0 之后是多线程了解吗？

Redis 只是在**网络 IO 处理**上变成多线程，但是实际执行命令还是由一个主线程来执行。

### 3. 为什么要Redis6.0之后要引入多线程呢？

1. **网络 IO 多路复用：**在Redis6.0中，采用了多线程来处理网络I/O，引入了多个IO 线程。每个 IO 线程使用独立的事件循环（Event Loop），通过网络 IO 多路复用技术来同时处理多个连接的读写事件。这样可以充分利用多核 CPU，提高网络 IO 的并发处理能力。
2. **提高并发连接数：** 多线程模型可以更好地处理大量并发连接，每个线程负责处理一部分连接的读写操作，避免了单线程处理大量连接时的性能瓶颈。这对于高并发的场景，特别是大规模的连接数情况下，能够显著提高性能。
3. **减少网络延迟：**通过多线程并行处理网络 IO，可以减少连接的响应时间，降低网络延迟。这对于需要快速响应的应用场景，如实时数据处理和高频率交互的系统，具有重要意义。

### 4. 为什么Redis 为「关闭文件、AOF 刷盘、释放内存」这些任务创建单独的线程来处理？️

是因为这些任务的操作都是很耗时的，如果把这些任务都放在主线程来处理，那么Redis主线程就很容易发生阻塞，这样就无法处理后续的请求了。后台线程相当于一个消费者，生产者把耗时任务丢到任务队列中，消费者（BIO）不停轮询这个队列，拿出任务就去执行对应的方法即可。

### 5. 为什么Redis单线程模型效率也能那么高？️

Redis采用单线程（网络 I/O 和执行命令）那么快，有如下几个原因：

- Redis的大部分操作**都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是**机器的内存或者网络带宽**，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis采用单线程模型可以**避免了多线程之间的竞争**，省去了多线程上下文切换带来的时间和性能上的开销，而且也一定不会导致**死锁**问题。
- Redis采用**I/O多路复用机制**处理大量的客户端Socket请求，IO 多路复用机制是指一个线程处理多个IO流，即select/epoll机制。在Redis单线程的情况下，该机制允许内核中同时存在多个监听Socket和已连接Socket，内核会一直监听这些Socket上的连接请求或数据请求。一旦有请求到达，就会交给Redis主线程处理，这就实现了一个Redis线程处理多个IO流的效果。

### 6. 为什么Redis操作是原子性的？如何保证原子性？

- 因为Redis是单线程的，Redis中的所有操作都是在一个单线程中执行，这样就可以避免并发的环境下多个线程同时修改同一个键值对的问题。在Redis中，任何一个操作都是原子性的，要么执行成功，要么执行不成功。如果一个操作包含多个步骤，那么这些步骤会被当成一个整体，要么全部执行成功，要么全部不执行。
- Redis保证原子性的方式主要有三种：

1. **Redis事务：**会将多个命令打包成一个事务进行执行，事务中的所有命令都会在一次操作中被执行，要么全部执行成功，要么全部不执行。
2. **Lua脚本：**则可以将多个操作打包成一个原子性的操作进行执行，这个操作要么全部执行成功，要么全部不执行。
3. **原子性操作：**用Redis提供的原子性操作INCR，则不会存在这种问题，因为INCR命令是原子性的。

### 7. Redis 6.0 之前为什么使用单线程？️

1. CPU并不是制约Redis性能表现的瓶颈，更多情况下是受到内存大小和网络I/O的限制，所以Redis核心网络模型和执行命令使用单线程是合理的；
2. **多线程**引入了程序执行顺序的不确定性，带来了**并发读写**的一系列问题；增加了系统复杂度；同时可能存在线程切换、甚至加锁解锁、死锁造成的**性能损耗**。

### 8. Redis 6.0 之后为什么引入了多线程？️

因为**随着网络硬件的性能提升**，Redis的性能瓶颈有时会出现在网络I/O的处理上。
所以为了提高网络I/O的并行度，Redis6.0对于网络I/O采用多线程来处理。但是对于命令的执行，Redis仍然使用单线程来处理。

------

## 五、Redis持久化

### 1. (中高频) Redis 如何实现数据不丢失？「说说Redis持久化方式？」

Redis 持久化指的是将 Redis 中的内存数据保存到硬盘中，Redis 服务器重启或崩溃后数据也不会丢失。

1. **AOF 日志**：每执行一条**写操作**命令，就把该命令以追加的方式写入到一个`.aof`文件里；
2. **RDB 快照**：将某一时刻的内存数据，直接以二进制的方式写入磁盘；
3. **混合持久化方式**：Redis4.0新增的方式，集成了AOF和RDB的优点；

### 2. 先执行命令还是先写AOF日志？为什么？  	

AOF 先执行命令后再记录日志。

1. 在命令执行成功之后再记录 AOF 日志，记录时无需对 Redis 命令进行语法检查，减小了检查开销；
2. 在命令执行成功之后再记录，不会阻塞当前写命令执行，加快了响应。

### 3. 先执行Redis命令后写AOF日志的风险在哪里？

1. 如果刚执行完命令Redis就宕机，会导致对应的修改丢失；
2. 可能会阻塞后续其他命令的执行（AOF记录日志是在Redis主线程中进行的）。

### 4. 听说过write-ahead logging预写式日志策略吗，你对这个有什么想法吗？

这个原则是先写日志，后执行命令，可以在宕机时能够损失更少的数据。Redis不采用这种策略是因为需要先先执行指令并检查语法错误，然后再将正确的指令写入日志文件。直接写入日志就无法保证指令正确。

### 5. 说说AOF执行流程？

分为3步

1. Redis 执行完写操作命令后，会将命令追加到 server.aof_buf 缓冲区；
2. 然后**通过write()系统调用**，将aof_buf缓冲区的数据写入到AOF文件，此时数据并没有写入到硬盘，而是拷贝到了内核缓冲区，等待内核将数据写入硬盘；
3. 内核根据 AOF 刷盘策略决定何时将数据写入硬盘。

### 6. AOF写回策略有几种？「AOF刷盘策略有哪些？」

AOF写回策略定义了又叫刷盘策略，规定了什么时候将内核缓冲区的数据写入到硬盘。

1. **Always**：每次写操作命令执行完后，同步将AOF日志数据写回硬盘；
2. **Everysec**：每隔一秒将缓冲区里的内容写回到硬盘；
3. **No**：意味着不由Redis控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1708473727602-d3927ec3-77ee-458d-af43-0194f597c1b3.png)

### 7. Redis 将执行的所有写操作命令都追加上去, 不会很大吗？

Redis支持重写机制，随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。举例来说，假设某个键值对被多条写命令反复修改过，最终也只需要**根据键值对最新的状态添加一条命令即可**，这样就减少了命令的数量。

### 8. AOF和RDB各自的特点？「如何选择AOF或RDB」

1. 单独使用RDB
   **优点：**RDB是压缩的二进制数据，很适合做数据备份，使用RDB文件恢复数据直接解析，不需要一条一条执行命令。
   **缺点：**数据安全性差**，**无法实现实时或秒级持久化数据，bgsave子进程写RDB文件时也占用CPU、内存资源
2. 单独使用AOF
   **优点：**可以实时或者秒级去持久化数据，能更好保证数据安全性、完整性；
   **缺点**：1. AOF体积太大时会重写，占用CPU、内存资源；2. 遇到数据库恢复的场景就会很慢，需要一条一条执行命令
3. 因此，为了保证数据的安全性完整性，又考虑到Redis故障宕机后的数据恢复，一般建议开启RDB和AOF的混合持久化。

------

## 六、Redis 内存管理

### 1. Redis 过期删除和内存淘汰策略？

```java
EXPIRE key seconds️
```

过期策略：Redis中可以通过EXPIRE命令设置key的过期时间，过期时间到期后，key将会自动被删除。Redis底层提供了两种不同的过期策略：

- **定时删除**：在设置key过期时间的同时，创建一个**定时器**。当过期时间到达时，就会立即删除该key。
- **惰性删除**：不会主动删除key，**在查询key时先检查该key是否过期**，如果过期就删除，否则返回该key的值。

Redis默认使用**惰性删除**策略。

内存淘汰机制：当Redis内存空间不足时，需要从内存中删除一些数据

- **noeviction**：新写入操作会**报错**，但不会删除任何数据，这是 **Redis 默认的淘汰策略**
- **allkeys-lru**：在键空间中，移除最近最少使用的 key（LRU算法）。
- **allkeys-random**：从所有key中随机选择一些进行删除。
- **volatile-lru**：在设置了过期时间的键空间中，移除最近最少使用的key（LRU算法）。
- **volatile-ramdom**：在设置了过期时间的 key 中随机选择一些进行删除。
- **volatile-ttl**：在设置了过期时间的key中，根据过期时间的先后顺序进行删除，越早过期的越优先删除。

### 2. MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

我们可以使用 Redis 的内存淘汰策略来实现，可以使用**allkeys-lru淘汰策略。**该淘汰策略是从 Redis 的数据中挑选最近最少使用的数据删除，这样频繁被访问的热点数据就可以保留下来。

### 3. 为什么会出现大Key？

1. **数据结构设计不合理**：当使用 Redis 的字符串类型存储较大的数据时，如果没有合理地切分数据。例如将大段文本内容存储在一个字符串类型的 Key 中，这会导致 Key 值很大。
2. **批量写入数据**：如果将大量的数据一次性写入到一个 Key（哈希、列表）中，也会导致大 Key 的问题。这种情况发生的场景一般是**批量导入数据**或者**数据迁移**的场景。

### 4. 大 Key带来的影响？

1. **内存占用过高**：大 key 占用过多的内存空间，可能导致可用内存不足，从而触发内存淘汰策略。在极端情况下，可能导致内存耗尽，Redis 实例崩溃，影响系统的稳定性。
2. **性能下降**：大 key 会占用大量内存空间，导致内存碎片增加，进而影响 Redis 的性能。对于大 Key 的操作，如读取、写入、删除等，都会消耗更多的 CPU 时间和内存资源，进一步降低系统性能。
3. **客户端超时阻塞**：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。
4. **引发网络阻塞**：如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。
5. **阻塞工作线程**：如果使用del删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。

### 5. **怎么解决大key？**

1. **拆分成多个小key**：这是最容易想到的办法，降低单 key 的大小，读取可以用 mget 批量读取。
2. 数据压缩。使用 String 类型的时候，使用压缩算法减少 value 大小。或者是使用 Hash 类型存储，因为Hash类型底层使用了压缩列表数据结构。
3. **设置合理的过期时间**：为每个 key 设置过期时间，并设置合理的过期时间，以便在数据失效后自动清理，避免长时间累积的大 key 问题。
4. **启用内存淘汰策略：**启用 Redis 的内存淘汰策略，例如LRU（Least Recently Used，最近最少使用），以便在内存不足时自动淘汰最近最少使用的数据，防止大Key长时间占用内存。
5. **数据分片**：例如使用 Redis Cluster 将数据分散到多个Redis实例，以减轻单个实例的负担，降低大Key问题的风险。
6. **删除大key**：使用 UNLINK 命令删除大 key，UNLINK 命令是 DEL 命令的异步版本，它可以在后台删除 key，避免阻塞 Redis 实例。

------

## 七、Redis 高可用

### 1. Redis如何保证可用性？

1. **主从复制**：将Redis主节点的数据复制到一个或多个从节点，可以提高可用性和读取性能
2. **哨兵模式**：哨兵模式会持续监控主节点和从节点的运行状态，主节点发生故障时，会自动将一个从节点提升为主节点，并通知管理员
3. **Redis Cluster**：通过分片将数据分配在多个节点上（根据键的哈希值），并在每个分片上设置多个副本，从而支持更大的数据集和更高的吞吐量。

### 2. Redis 主从复制？

**主从复制模式**指的是主服务器可以进行读写操作，发生写操作时自动将写操作同步给从服务器，而从服务器一般是只读，并接受主服务器同步过来写操作命令，然后执行这条命令。

这种模式可以保证主从服务器之间的数据一致性。

### 3. Redis 分片集群了解吗？

### 4. Redis 的集群管理模式节点怎么管理