

## 一、MySQL基础

### 1. **用你的理解讲讲数据库设计的三范式？**

1. **「第一范式」**：数据库中的字段具有原子性，**不可再分**；
2. **「第二范式」**：**「在第一范式的基础上」**，一张表中每个属性都是原子的，并且不存在对主键的**部分函数依赖****；
   **表：学号、课程号、姓名、学分;
3. **「第三范式」**：**「建立在第一，第二范式的基础上」**，不存在属性对主键的**传递依赖**。
   表: 学号, 姓名, 年龄, 学院名称, 学院电话

### 2. (中高频) 执行一条 SQL 查询语句，期间发生了什么？

MySQL大体上分为**Server层**和**存储引擎层**

Server 层主要用于建立连接、分析和执行 SQL：模块主要包括连接器、查询缓存、分析器、优化器、执行器等，还有一个通用的日志模块binlog

存储引擎主要负责数据的存储和读取：采用可替换的插件式架构，支持 InnoDB、MyISAM、Memory 等存储引擎。

1. 首先**连接器跟客户端建立连接**，检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限（在MySQL8.0 版本以前）会先**查询缓存**。缓存命中就返回结果，如果没有缓存，执行下一步；
2. **分析器**进行词法分析，提取 sql 语句中 select 等关键元素，然后判断 sql 语句是否有语法错误等等。
3. 接着**优化器**会对语句进行优化并确定最终的执行计划，交给执行器；
4. 最后**执行器**会调用数据库引擎接口，返回引擎的执行结果。

### 3. 执行一条update语句的全过程？

1. **SQL 解析与优化**：MySQL 解析并优化 UPDATE 语句，生成最优的执行计划。
2. **执行器**：执行计划通过执行器提交给存储引擎，找到需要更新的行。
3. **存储引擎处理**：InnoDB 加行锁并更新数据，同时记录Undo Log和Redo Log。
4. **事务处理**：过程中通过事务机制确保数据的一致性与持久性，事务提交时刷新Redo Log保证持久化。

### 4. 怎么看执行计划？如何理解其中各个字段的含义？

![img](https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoEjUXOnibfMR6z5w1hgaU4bTSo3ibANJPSGITPxksHrN4lLuviaFrsk69ThloqZz7rs2a2ibicuBRvXTw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

**id**：是 select 语句的序号，MySQL将 select 查询分为简单查询和复杂查询。

**select_type**：表示对应行是是简单还是复杂的查询。

**table**：表示explain的一行正在访问哪个表。

**type**：最重要的列之一。表示关联类型或访问类型，即 MySQL 决定如何查找表中的行。从最优到最差分别为：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL

**possible_keys**：显示查询可能使用哪些索引来查找。

**key**：这一列显示mysql计划采用的索引，但不代表实际就会使用。

**key_len**：显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。

**ref**：这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名。

**rows**：这一列是 mysql 估计要读取并检测的行数，注意这个不是结果集里的行数。

**Extra**：显示额外信息。比如有 Using index、Using where、Using temporary等。

### 5. MySQL 的数据存放在哪个文件？

一张数据库表的数据是保存在「表名字.ibd」的文件里的，这个文件也称为**独占表空间文件**。

### 6. InnoDB 行格式有哪些？

行格式就是**记录一条记录的存储结构**。

InnoDB 提供了4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。

1. Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
2. 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，**行格式默认设置成 Compact**。
3. Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。
4. Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次重点介绍 Compact 行格式，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。

### 7. SQL 查询语句执行顺序？

SQL 查询语句执行顺序一般不同于书写顺序

1. FROM：
   首先确定要查询的数据源，包括表或视图。
   处理 JOIN 操作，将多个表进行连接。
2. WHERE：
   过滤数据源中的行，只有满足 WHERE 条件的行才会进入下一步。
3. GROUP BY：

将数据按条件进行分组。

针对每个组进行聚合计算。

1. HAVING：

过滤分组后的数据，只有满足 HAVING 条件的组才会进入下一步。

1. SELECT：
   执行列选择和表达式计算。
   生成结果集的最终列。
2. DISTINCT：
   从结果集中去除重复的行。
3. ORDER BY：

对结果集进行排序。

1. LIMIT / OFFSET：

限制结果集的返回行数，实现分页。



### 8. MySQL 中有哪些 join？

**内连接（INNER JOIN）**：返回两个表中满足连接条件的匹配行。没有匹配记录的行不会出现在结果集中。

**左连接（LEFT JOIN）**：返回左表中的所有记录，以及右表中匹配的记录。右表中没有匹配记录的行结果为 NULL。

**右连接（RIGHT JOIN）**：返回右表中的所有记录，以及左表中匹配的记录。左表中没有匹配记录的行结果为 NULL。

**全连接（CROSS JOIN）：**返回两张表的笛卡尔积

### 9. 进行范围查找能想到哪些方法？



------

## 二、MySQL字段类型

### 1. MySQL 的 NULL 值会占用空间吗？

MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。「NULL值列表」每列代表一个二进制位，占用 1 字节空间，二进制位为 1 时该字段为 NULL，二进制为 0 时该字段不为 NULL。

当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。

### 2. MySQL 怎么知道 varchar(n) 实际占用数据的大小？

MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。

### 3. VARCHAR(n) 中n最大取值是多少？

MySQL 规定了除了 TEXT、BLOBs 这种大对象类型，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 字节的数据。

存储字段类型为 VARCHAR(n) 的数据时，其实分成了三个部分来存储：

1. 真实数据
2. 变长字段字节数列表（<255 时用 1 字节，>255 用 2 字节）
3. NULL 值列表字节数 

如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。

### 4. 行溢出后，MySQL 是怎么处理的？

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。

### 5. UNSIGNED属性有什么用？

表示无符号整数，不允许负值，可以将存储范围扩大为原先2倍。

### 6. MySQL中 CHAR 和 VARCHAR 的区别？哪种性能更好？

CHAR 和 VARCHAR 都是 MySQL 中存储**字符串**的数据类型。
主要区别在于：
CHAR 是**固定长度**的数据类型：1. 在创建表时指定一个固定的长度；2. 存储时会在右边**填充空格**以达到指定的长度；
VARCHAR 是**可变长度**的数据类型，只占用**实际存储字符串长度**所需的存储空间，行格式会维护一个「变长字段长度列表」，里面记录了实际占用的字节数。

ps：CHAR 填充空格意味着需要从磁盘读写更多的数据、耗费更多内存、查找数据时删除空格可能也会耗费一些 CPU 性能。

### 7. 为什么不推荐使用 TEXT 和 BLOB？

TEXT 可以存储很大的字符串，长文本数据，比如博客内容

BLOB 用于存储二进制大对象，例如图片、音视频等文件

数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：

1. 不能有默认值。
2. 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
3. 检索效率较低。
4. 不能直接创建索引，需要指定前缀长度。
5. 可能会消耗大量的网络和IO带宽。
6. 可能导致表上的 DML 操作变慢。

### 8. 为什么不用字符串存储日期？

1. 字符串占用的空间更大；
2. 字符串存储的日期效率比较低，无法直接使用日期相关的 API 进行计算和比较。

### 9. DATETIME 和 TIMESTAMP 的区别是什么？

DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。

### 10. Boolean 类型如何表示？

用`TINYINT(1)`表示布尔值，用 1 对应 ture，0 对应 false。

### 11. DECIMAL 和 FLOAT/DOUBLE 的区别是什么？

DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。
DECIMAL 可以存储精确的小数值，例如货币、余额；FLOAT/DOUBLE 只能存储近似的小数值。

### 12. NULL 和 '' 的区别？

1. 含义不同：NULL 表示不存在、未定义；空值字符串代表明确的长度为 0 的字符串；
2. 空间占用：'' 的长度是 0，不占用存储空间；NULL 通过 NULL 值列表标识，至少占 1 个字节。
3. 处理方式：查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULLl 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而''是可以使用这些比较运算符的。
4. 函数处理：假设一列叫 name，聚合函数 COUNT 会忽略 NULL 值，但会计算空字符串。

------

## 三、MySQL存储引擎

### 1. (中高频) MySQL 支持哪些引擎？默认使用哪个？

InnoDB提供了对事务ACID的支持，支持行级锁、外键约束；

MyISAM不支持事务也不支持行级锁和外键约束

MEMORY就是把数据放在内存中，处理速度快，但安全性不高（可能宕机，没有事务日志恢复

MySQL默认存储引擎是**InnoDB**

### 2. MyISAM 和 InnoDB 有什么区别？

1. InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。
2. MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义四个隔离级别。
3. MyISAM 不支持外键，而 InnoDB 支持。
4. MyISAM 不支持 MVCC，而 InnoDB 支持。
5. MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。
6. InnoDB 的性能比 MyISAM 更强大。

### 3. InnoDB 底层是如何读写数据的？

InnoDB的数据是按「数据页」为单位来读写，默认数据页大小为 16KB，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

------

## 四、MySQL索引

### 项目中如何使用索引的？

用到最多的还是唯一索引，主键索引

1. **唯一索引**（需求：避免重复下单，保证唯一性等）
   为了保证用户不会重复下单，将（商品id，用户id）作为唯一索引，当重复插入订单数据的时候会报错
   用户的手机号，邮箱号用唯一索引
2. **普通索引**（需求：提升查询速度）
   给商品id，订单id添加索引，在查询的时候可以去有效加快查询速度

### 1. 索引基础

#### 1.1. MySQL索引了解吗？MySQL 索引的优点？（为什么要使用索引？）

索引是一种存储引擎用于**快速查询数据**的数据结构，其本质可以看成是一种排序好的数据结构。

1. 使用索引可以减少磁盘IO次数，从而**大大加快数据的检索速度**；
2. 通过创建唯一性索引，可以保证数据库中每一行数据的**唯一性**。

（补充：由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（*假设一个节点的大小「小于」操作系统的最小读写单位块的大小*），也就是说**树的高度就等于每次查询数据时磁盘IO操作的次数**，所以树的高度越高，就会影响查询性能。）

#### 1.2. MySQL索引的缺点？

1. 创建和维护索引耗费时间，这种时间随着数据量的增加而增大；需要用物理文件存储，占用空间
2. 对数据表中数据进行增删改时，索引也会动态修改，可能降低 SQL 执行效率；

#### 1.3. (高频) 什么场景适合使用索引？

1. 字段有唯一性限制的，比如商品编码，订单号，可以使用唯一索引；
2. 经常用于 WHERE 查询条件的字段，这样能够提高表的查询速度。如果查询条件不止一个字段，可以建立联合索引。
3. 经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询时不需要再去做一次排序了，因为 B+Tree 叶子节点是排序好的。 

#### 1.4. (高频) 什么时候不需要创建索引？

1. 表数据太少，创建索引没有意义，反而会增加开销；
2. WHERE 条件，GROUP BY，ORDER BY 里不常用的字段，起不到定位的字段通常是不需要创建索引的，因为索引本身会占用物理空间；
3. 字段中有大量重复数据时不需要创建索引，因为查询优化器发现某个值在表数据行中出现的百分比很高的时候，它一般会忽略索引，进行全表扫描；
4. 经常更新的字段不需要创建索引，因为索引字段值改变后 B+ 树会跟着调整，可能会影响 SQL 语句的效率。

------

### 2. 索引结构

#### 2.1. 为什么不使用二叉搜索树作为索引的底层结构？

- 

1. 大数据量情况下，层级较深，检索速度慢；
2. 如果插入的序列是排好序的话，还会形成一个链表，这种极端的情况会导致查询性能大大降低。

#### 2.2. (高频) 为什么 InnoDB 使用 B+ 树作为存储引擎？

- 

1. 磁盘 I/O 效率：B+ 树叶子节点既存放索引也存放数据，其他非叶子节点节点只存放键。因此数据量相同情况下，B+ 树非叶子节点存放更多索引，B+ 树更加**矮胖**，因为磁盘 I/O 由树高度决定，查询节点的磁盘 I/O 次数会减少；插入、删除、查询平均时间复杂度为 O(logN)。
2. 范围查询：B+ 树的叶子节点**保存指针指向相邻的叶子节点**，因此范围查询的效率更高；
3. 顺序性：B+ 树的叶子节点根据索引键大小排序，构成双向链表，在排序和顺序遍历场景效率高；
4. 结构稳定：B+ 树有大量的冗余节点，这些冗余索引让 B+ 树在插入、删除时**不会像 B 树那样发生复杂的树结构变化**，因此插入删除效率更高。

#### 2.3. B+ 树是如何进行查询的？

InnoDB 采用 B+ 树作为索引，每个节点都是一个数据页。

假设查询条件用的聚簇索引，在定位到叶子节点后可以直接获得数据；

假设使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」。如果查询的数据不在二级索引里，就需要先在二级索引得到主键值，然后通过「回表」得到数据记录。

#### 2.4. B+ 树和 B 树的区别？

- 

1. B树的所有节点**既存放索引也存放数据**，而B+树只有叶子节点既存放索引也存放数据，其他非叶子节点节点只存放键。因此数据量相同情况下，B+树非叶子节点存放更多索引，B+树更加**矮胖**，因为磁盘 I/O 由树的高度决定，查询节点的磁盘 I/O 次数会减少。
2. B树的叶子节点都是独立的，想要实现范围查询**必须多次遍历树节点**，而B+树的叶子节点**保存指针指向相邻的叶子节点**，因此范围查询的效率更高。
3. B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让B+树在插入、删除时不会像B树那样发生复杂的树结构变化，因此插入删除效率更高；

综上，B+树与B树相比，具备更少的IO次数、更稳定的查询效率和更适于范围查询这些优势。

#### 2.5. B+ 树索引和 Hash 索引区别是什么？

- 

1. B+ 树可以进行范围查询，Hash 索引不能。
2. B+ 树支持联合索引的最左侧原则，Hash 索引不支持。
3. B+ 树支持order by排序，Hash 索引不支持。
4. Hash 索引在等值查询上比 B+ 树效率更高。
5. B+ 树使用 like 进行模糊查询的时候，like后面（比如%开头）的话可以起到优化的作用，Hash 索引根本无法进行模糊查询。

#### 2.6. B+树，红黑树，哈希表表作为索引的数据结构各自的优缺点？

**B+树**

**优点**：

1. **平衡性**：B+树是一种自平衡树，所有叶子节点处于同一层，保证了查找、插入和删除操作的时间复杂度为 O(logN)。
2. **磁盘友好**：B+树的节点通常包含多个元素，可以有效利用磁盘块（页面），减少磁盘I/O操作的次数。适用于数据库系统中的大规模数据存储和检索。
3. **范围查询**：B+树的叶子节点通过链表相连，支持高效的范围查询和顺序访问。

**缺点**：

1. **复杂性**：实现和维护相对复杂，涉及节点的分裂和合并操作。
2. **内存消耗**：相比红黑树，B+树在内存中的指针开销更大，因为每个节点包含多个子节点指针。

**红黑树**

**优点**：

1. **平衡性**：红黑树是一种自平衡二叉搜索树，确保任何一个节点到其叶子节点的最长路径不超过最短路径的两倍，保证了查找、插入和删除操作的时间复杂度为 O(log n)。
2. **操作简单**：相比 B+ 树，红黑树的插入和删除操作相对简单，因为每个节点只有两个子节点。

**缺点**：

1. **范围查询性能较差**：由于红黑树没有顺序链表结构，范围查询需要中序遍历，性能不如 B+ 树。
2. **内存局部性差**：由于红黑树的节点可能分布在内存的不同位置，导致缓存命中率低，不如 B+ 树高效。

**哈希表**

**优点**：

1. **快速查找**：哈希表的查找、插入和删除操作的平均时间复杂度为 O(1)，在大多数情况下非常高效。
2. **简单实现**：哈希表的实现和使用相对简单，适合快速查找和更新操作。

**缺点**：

1. **不支持顺序访问和范围查询**：哈希表没有顺序关系，不适合需要顺序遍历或范围查询的应用场景。
2. **哈希冲突**：哈希冲突是不可避免的，需要处理冲突的机制（如链地址法或开放地址法），这会影响性能。
3. **空间效率**：哈希表需要额外的空间来处理冲突，加载因子过高会降低性能，过低会浪费内存。

------

### 3. 索引分类

#### 3.1. (高频) 说说索引的分类？

- 

1. 按「数据结构」分类：

B+tree 索引：所有数据存放在叶子节点，查询时间复杂度 O(logn)，适合范围查询

Hash 索引：适合等值查询，效率高

Full-text 全文索引：底层使用的是倒排索引，一般在文本类型上创建

1. 按「底层存储」分类：

聚簇索引：叶子节点存储索引加一整行记录，找到索引就找到数据

二级索引：叶子节点存储的不是整行记录，而是数据行的的主键值

1. 按「字段逻辑」分类：

主键索引：不允许有空值，是特殊的唯一索引

唯一索引：每个值唯一，但是允许为空

普通索引：MySQL 中基本索引，允许空值和重复值

联合索引：多个字段创建的索引

#### 3.2. 聚簇索引与非聚簇索引的区别？

- 

1. 唯一性：一个表中只能有一个聚簇索引，而非聚簇索引可以存在多个；
2. 存储方式：聚簇索引的 B+Tree 的叶子节点存放的是实际数据；非聚簇索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。
3. 查询效率：基于聚簇索引能够快速定位到数据，因为数据就在叶子节点里；而非聚簇索引可能需要回表，因此可能更慢。

#### 3.3. 什么叫回表查询？什么叫索引覆盖？

*回表*

如果查询语句使用了二级索引，但是要查询的数据不是主键值，二级索引找到主键值后，再去聚簇索引中获得数据行。也就是要查2个B+树才能查到数据。

*索引覆盖*

查询所需要的列都在索引里，查询就可以完全在二级索引中执行，从而不需要回表。

#### 3.4. 非聚集索引一定要回表查询吗？

非聚集索引不一定要回表查询。如果要查的数据在非聚集索引 B+ 树的叶子节点里，就不需要回表查询。

------

### 4. 索引性能分析

#### 4.1. 如何查看某条SQL语句是否⽤到了索引？

#### 



------

### 5. 索引使用规则

#### 5.1. 什么是最左前缀匹配原则？

- 

最左前缀匹配原则指的是 MySQL 会根据索引中的字段顺序，从左到右依次匹配**查询条件**中的字段。例如创建一个联合索引 (a1, a2, a3)，相当于创建了 (a1)、(a1, a2) 和 (a1, a2, a3) 三个索引，查询时会将查询条件与索引中的最左侧字段相匹配，这就是最左前缀匹配原则。

#### 5.2. 什么时候适合建立联合索引？

1. WHERE 查询条件涉及多个列；
2. 涉及多个列的排序或者分组；
3. 

#### 5.3. 什么时候不需要创建索引？

- 

1. 表中数据很少；
2. `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的作用是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
3. 字段中存在大量重复、区分度低的数据；「比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描」
4. 经常更新的字段不用创建索引；「比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的」

#### 5.4. 有什么优化索引的方法？

- 

1. 前缀索引优化；
2. 覆盖索引优化；
3. 主键索引最好是自增的；
4. 防止索引失效；

#### 5.5. **(中高频) MySQL 索引失效的情况有哪些？**

1. 使用左或者左右模糊匹配：例如 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效，
   因为索引底层的 B+ 树叶子节点「索引键」是有序排列存储的，只能根据**字符串前缀**进行比较，没法比较后缀。
2. 在查询条件中对索引列使用函数：例如 length(name)，因为索引保存的是字段原始值，而不是函数计算过后的值，因此无法走索引

1. 在查询条件中对索引列进行表达式计算，也是无法走索引的。

1. MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。

1. 联合索引：1.没有遵循最左匹配原则，会导致索引失效；2.如果某一列使用了范围查询，后续列的索引可能无法被有效使用

1. 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

#### 5.6. 哪种 count 性能最好？



![img](https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png)

#### 5.7. 索引下推是什么？

#### 5.8. MySQL中，对A和B两个字段建立联合索引

1. **查询A = 1and B=1的时候会出现什么情况？**
   先通过 A = 1 定位到所有 A 为 1 的记录，再通过 B = 1 在这些记录中进一步筛选出符合条件的记录。

1. **如果是B > 3 and A = 1呢？
   **有 A = 1 的条件，MySQL 会首先利用 A 的索引部分，然后在 A = 1 的记录中查找 B > 3 的记录。
2. 如果是  3 < A < 5 and B >3 呢？
   如果某一列使用了范围查询，后续列的索引可能无法被有效使用。A走了索引，但是B失效

#### 5.9. MySQL中为什么要用自增ID？随机生成的ID有哪些问题？

1. 新增的数据直接插入到表的末尾，不会破坏树的结构，提升了插入效率
2. 唯一性保证，并且简单易用



1. 因为随机生成的 ID 没有顺序性，新插入的数据可能会被插入到 B+ 树的任意位置，这会导致频繁的节点分裂、平衡操作
2. 随机 ID 会导致新数据分散到不同的数据页中，使得数据页经常处于未完全填满的状态，增加了空间浪费

------

## 五、MySQL事务

### 1. **(高频) 说说 MySQL 事务？**说说事务四大特性？

- 

数据库事务指多个 SQL 语句**构成一个逻辑上的整体**，并且遵循：要么全部执行成功，要么全部不执行**。**

1. **原子性**：事务是**最小**的执行单位，不允许分割，确保了事务中的 SQL 操作要么全部执行，要么全部不执行。
2. **一致性**：指事务执行前后，数据库保持一致性状态。如果执行后数据是矛盾的，事务就会回滚到执行前的状态（执行前是一致的）。比如说，转账双方的金额之和在转账前后是相等的。
3. **隔离性**：并发环境中事务是相互隔离的，一个事务的执行不能被其他事务干扰，每个事务都有各自完整的数据空间。
4. **持久性**：一个事务被提交之后，它对数据库中数据的改变是持久的，即使系统发生故障也不会丢失。

### 2. InnoDB 引擎通过什么技术保持这些特性？

原子性通过 undo log（回滚日志）；

隔离性通过锁机制（可串行化）或者 MVCC（读取已提交和可重读）；

持久性通过 redo log（重做日志）；

一致性 = 持久性 + 原子性 + 隔离性

### 3. 并发事务带来的问题？不可重复读和幻读有什么区别？

1. ***脏读***
   事务A对数据X进行了修改，这时另外一个事务B读取了这个还未提交的数据，但事务A突然回滚，导致数据并没有被提交到数据库，那么事务 B 读取到的就是脏数据。
   ![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1711669322359-b93806da-2aea-4ccc-8d60-47b2af469efc.png)
2. ***丢失修改***
   事务A读取一个数据X时，事务B也访问了该数据，那么在事务A中修改了这个数据后，事务B也修改了这个数据。因此事务A的修改结果就丢失。
   ![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1711670532877-ce742612-1674-401d-a1ea-a388b5e3afbc.png)
3. ***不可重复读***
   假设事务A多次读同一数据X，过程中事务B修改了该数据。在事务A中的两次读数据之间，由于事务B的修改导致事务A两次读取的数据可能是不一样的。
   ![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1711679289837-82d799c2-1096-4383-b1f0-b6da010bdabe.png)
4. ***幻读***
   发生在事务A读取了几行数据，接着另一个事务B同时插入了一些数据时。在随后的查询中，事务A发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
   ![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1711679298101-a952e37a-54d5-499d-acb3-1aafc6d92e8c.png)



**不可重复读和幻读的区别**

1. 不可重复读主要指的是，多次读取一条记录，发现其中某些记录的值被修改；
2. 幻读的重点在于多次执行同一条查询语句（DQL）时，发现查到的记录增加了。

### 4. 当前读和快照读有什么区别？

**快照读**（一致性非锁定读）

一般指普通的 SELECT 语句，通常发生在「读提交」和「可重复读」级别下，通过 MVCC 实现。

```sql
SELECT ...
```

**快照的含义即记录的历史版本**，每行记录可能存在多个历史版本。快照读的时候如果记录在执行删除或更新，读取操作不会阻塞，而是去读取行的快照。对于「读提交」级别，InnoDB 读取行记录的最新一份数据快照。对于「可重复读」级别，读取本事务开始时的行数据版本。



**当前读**（一致性锁定读）

就是在读取时给记录加 X 锁和 S 锁

```sql
# 对读的记录加一个X锁
SELECT...FOR UPDATE
# 对读的记录加一个S锁
SELECT...LOCK IN SHARE MODE
# 对读的记录加一个S锁
SELECT...FOR SHARE
# 对修改的记录加一个X锁
INSERT...
UPDATE...
DELETE...
```

### 5. 并发事务控制方式？

**锁**或**MVCC，**锁是悲观锁的思想，MVCC是乐观锁的思想。
**通过锁来显式控制共享资源**，MySQL中通过读写锁来实现并发事务控制。

- **共享锁（S 锁）**：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取，又叫做锁兼容；
- **排他锁（X 锁）**：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁，锁不兼容。

读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 **表级锁(table-level locking)** 和 **行级锁(row-level locking)** 。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁）。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。



**MVCC** 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。

MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。

- undo log : undo log 用于记录某行数据的多个版本的数据。
- read view 和 隐藏字段 : 用来判断当前版本数据的可见性。

### 6. (**高频)** MySQL 事务的隔离级别？默认隔离级别是什么？

- 

1. **读取未提交**：允许读取尚未提交的数据变更。
2. **读取已提交 RC**：允许读取事务已经提交的数据。
3. **可重复读 RR**：保证事务期间同一字段多次读取结果都是一致的。
4. **串行化**：完全服从 ACID 的隔离级别，所有的事务依次逐个执行，互相不会产生干扰。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716167692762-9d04b38c-e8de-4155-829f-f6b50c653135.png)

MySQL InnoDB存储引擎的默认支持的隔离级别是**可重读**

### 7. MySQL 的隔离级别分别是怎么实现的？

- 

1. 「读未提交」可以读未提交事务修改的数据，所以直接读取最新数据；
2. 「串行化」通过加读写锁避免线程并发访问数据库
3. 「读提交」和「可重复读」都是通过 Read View 来实现，区别在于创建 Read View 的时机不同，Read View 可以看成一个数据快照：
   读取已提交隔离级别是**在每次执行select的时候生成一个新的Read View**，如果在事务期间另外一个事务修改了记录并提交了事务，意味着Read View 中的字段值改变，通过比对， 那么事务期间多次读取同一条数据前后结果可能不一致。
   RR 隔离级别是只**在启动事务时生成一个 Read View**，然后整个事务期间都在用这个 Read View，保证了在事务期间读到的数据都是事务启动前的记录，从而实现可重复读。

### 8. (**高频)** 说说对 MVCC 的理解？

首先，MVCC 只用在**读取已提交**和**可重复读**这两种隔离级别下

1. MVCC 核心思想是通过创建数据的多个版本和使用**快照读**取来实现并发控制，快照读读的是数据的历史版本，写操作会创建新版本，并确保旧版本仍然可用。
2. 底层实现原理是：是隐藏字段 + Read View + undo log，InnoDB 通过行记录里隐藏字段的事务 id (trx_id) 和 Read View 里的字段做一些比较来判断该行记录是否对当前事务可见。如果可见就直接读取结果，如果不可见，就通过隐藏字段的 roll_ptr 指针找到旧版本并读取。

### 9. 可重复读隔离级别是否解决幻读？

「可重复读」很大程度避免了幻读，但并不是完全解决。

读操作一般分为两种，快照读和当前读

1. 针对「快照读」，通过 MVCC 的方式解决幻读，因为可重复读隔离级别下，事务执行时看到的数据版本和事务启动前看到的数据是一样的。即使中途有其他事务插入一条数据，也是查询不到这条数据的。
2. 针对「当前读」，通过next-key lock解决幻读，执行select for update 语句时，会加上next-key lock，如果其他事务在 next-key lock插入一条记录会被阻塞，也就避免了幻读问题。

------

## 六、MySQL锁

### 1. (**高频)** MySQL有哪些锁？

- 

1. **全局锁**：全局锁是对整个数据库上锁，应用场景一般是**数据库数据备份**，上锁期间数据库处于只读状态。
2. **表级锁：** 对当前操作的整张表加锁，本质是对**非索引字段**加锁

1. 元数据锁：对数据库表进行任何操作时都会自动加上元数据锁，为了保证当用户对表进行 CRUD 操作时，其他线程不会对表结构进行改变。元数据锁在事务提交之后会释放
2. 意向锁：对某些**行记录**加共享/独占锁之前，**需要先在表级别加上一个意向共享/独占锁**，别的线程想操作时要先看是否有意向锁，有的话避免扫描全表。
3. AUTO-INC 锁：表里的主键一般设置为自增，插入数据的时候可以为主键自动赋值，通过 AUTO-INC 锁实现。插入数据的时候会加一个 AUTO-INC 锁，然后被 AUTO-INCREMENT 修饰的字段赋递增的值，插入语句执行完成后才会释放锁。其他语句想要插入都会被阻塞，从而保证主键是连续递增的。

1. **行级锁：** 仅对相关的记录上锁（一行或者多行记录），是针对**索引字段**加锁（避免扫描全表），行级锁是 MySQL 中锁定粒度最细的一种锁。

1. 记录锁：锁住的是一条记录，记录锁分为共享锁、排他锁
2. 间隙锁：只存在于可重复读隔离级别下，主要是为了解决幻读。
3. Next-key 锁：临键锁是记录锁和间隙锁的组合，锁定一个范围并且锁定记录本身。既可以防止记录被修改，又可以阻止其他事务将新的记录插到间隙当中。
4. 插入意向锁：一个事务在插入一条记录的时候，需要判断插入位置是否已经被其他事务加了间隙锁。如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的事务提交，在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录且处于等待状态。

### 2. 全局锁应用场景？

全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为表结构或数据的更新，而出现备份文件的数据与预期的不一样。

### 3. 加全局锁的缺点？如何避免？

加上全局锁，意味着整个数据库都是只读状态。如果数据库里有很多数据，备份就会花费很长的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。

### 4. 哪些操作会加表级锁？哪些操作会加⾏级锁？请简单举例说⼀下。

会加表级锁的操作：

1. ALTER TABLE语句：例如修改表结构、添加或删除列等操作。
2. LOCK TABLE table_name WRITE/READ 语句：显式地对表加写锁或读锁。

会加行级锁的操作：

1. 大多数的 SELECT... FOR UPDATE 语句：用于在读取数据时锁定符合条件的行，以防止其他事务对这些行进行修改，直到当前事务完成。
2. INSERT、UPDATE、DELETE 语句在执行时通常会对操作涉及的行加行级锁。

### 5. InnoDB 有哪几类行锁？

InnoDB行锁通过对索引数据页上的记录加锁实现，支持三种行锁定方式：

- **记录锁（Record Lock）**：也被称为记录锁，属于单个行记录上的锁。
- **间隙锁（Gap Lock）**：锁定一个范围，不包括记录本身。
- **临键锁（Next-Key Lock）**：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。

### 6. Next-Key Lock的加锁范围？





### 7. 行级锁的使用有什么注意事项？

InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致**扫描全表**对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！

不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。

### 8. 共享锁和排他锁是什么？

- **共享锁（S 锁）**：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。
- **排他锁（X 锁）**：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

### 9. 意向锁有什么作用？

意向锁**不会直接加锁**，而是作为一种表级锁提高并发控制的效率，分为意向共享锁和意向排他锁。

指示事务获取什么类型的行级锁，使得在进行表级别的锁兼容性检查时更加高效。如果没有意向锁，系统需要扫描表中的所有行锁来判断是否可以获取表级别的锁。

### 10. 插入一条数据时加锁范围是什么？

执行插入操作时，主要会设置表级别的意向锁（IS 或 IX）和行级别的插入意向锁。这些锁的目的是确保插入操作不会与其他事务的操作冲突MySQL如何使⽤乐观锁和悲观锁？

### 11. MySQL乐观锁 悲观锁 各自适用场景？





### 12. 自增锁有了解吗？



------

## 八、MySQL日志

### 1. (中高频) MySQL中常⻅的⽇志有哪些？

1. undo log 是 InnoDB 存储引擎层生成的日志
   当事务回滚时，将数据恢复到修改前的样子
   用在 MVCC机制中，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，通过undo log读取之前版本的数据实现非锁定读。
2. redo log 是物理日志，记录了某个数据页做了什么修改，每当执行一个事务就会产一条或者多条物理日志
3. binlog (归档日志）是 Server 层生成的日志，主要 于数据备份和主从复制。
4. relay log 中继日志， 在主从复制场景下，slave通过io线程拷 master的bin log后本地生成的日志

### 2. 慢查询⽇志有什么⽤？

### 3. 说说binlog？

binlog是MySQL的二进制日志，用于记录所有数据更改操作。它有三个主要功能：

1. 数据恢复：可以用于恢复数据到某个特定时间点。
2. 主从复制：在 MySQL 主从复制机制中，从库通过读取主库的 binlog 来实现同步。
3. 审计：可以追踪和分析数据库中的数据更改。

通过 binlog，可以有效地进行数据恢复和实现数据库高可用架构。

### 4. redo log如何保证事务的持久性？

### 5. MySQL如何刷盘？

查询都是先从Buffer Pool中去找，更新也是先去Buffer Pool中更新

然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725767060833-a4448482-0d79-42db-b793-be3338f1e526.png)

### 6. ⻚修改之后为什么不直接刷盘呢？

### 7. binlog和redolog有什么区别？

### 8. undo log的作用？

1. 每一个事务对数据的修改都会被写到undo log，执行事务过程中出现错误或者需要执行回滚操作的话，MySQL都利用undo log将数据恢复到事务执行前的状态。
2. 另一个作用是 MVCC ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 undo log 读取之前的版本数据，以此实现非锁定读

### 9. 平时项目会打印什么日志信息？

1. 会打印关键业务流程的中间执行结果，比如用户注册、登录、下单后的状态，以及重要的相关的参数和返回值。
2. 系统的错误和异常信息，包括错误代码、错误消息、发生的位置以及相关的上下文数据
3. 业务层访问数据库并进行相关操作时会打印SQL语句，用于检查业务代码逻辑是否正确

------

## 九、MySQL性能优化

### 1. 日常工作中你是怎么优化SQL的？

- 

1. 避免使用 SELECT*（消耗CPU，无法使用索引覆盖，避免表结构变更的影响）
2. 利用延迟关联（将分页查询和关联查询分离）或者 子查询来优化超多分页的场景
3. 尽量避免多表做join（join效率很低），解决：存储冗余数据，使用缓存，应用层处理
4. 尽量不去使用外键和级联（对分库分表不友好）
5. 选择合适的字段类型（节约存储空间）
6. 使用UNION ALL代替UNION，UNION会进行去重操作，耗时，消耗CPU资源
7. 优化慢SQL等
8. ...

参考：《编程指北》

### 2. (中高频) 什么是慢查询？原因是什么？MySQL慢查询怎么优化？

- 





### 3. 能用 MySQL 直接存储文件吗？

一般不用 MySQL 直接存储文件，因为1.会消耗过多存储空间，2.还会影响数据库性能。

一般可以使用一些文件存储服务，数据库可以存储文件地址信息。

### 4. MySQL 如何存储 IP 地址？

MySQL 中提供两种方法可以存储 IP 地址：

- `INET_ATON()`：把 ip 转为无符号整型 (4-8 位)，可以节省存储空间；
- `INET_NTOA()`：把整型的 ip 转为地址

### 5. 如何分析 SQL 语句的性能？什么是执行计划？

- 

我们可以使用`EXPLAIN`命令来分析SQL的**执行计划**。

**执行计划**是指一条SQL语句在经过MySQL查询优化器的优化后，具体的执行方式。

### 6. 数据冷热分离如何做？

数据冷热分离是指根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，分开存储。热数据指的是，经常被访问和修改的且需要访问的数据，冷数据是指不被经常访问的数据，对当前项目的业务价值较低。

冷热数据划分方式有两种：

1. **按时间维度划分**：按照数据的创建时间、更新时间、过期时间等，将一定时间段内的数据视为热数据，超过该时间段的数据视为冷数据。例如，订单系统可以将 1 年前的订单数据作为冷数据，1 年内的订单数据作为热数据。这种方法适用于数据的访问频率和时间有较强的相关性的场景。
2. **访问频率区分**：将高频访问的数据视为热数据，低频访问的数据视为冷数据。例如，内容系统可以将浏览量非常低的文章作为冷数据，浏览量较高的文章作为热数据。这种方法需要记录数据的访问频率，成本较高，适合访问频率和数据本身有较强的相关性的场景。

### 7. 常见的数据库优化方法有哪些？

1. 索引优化
2. 读写分离和分库分表
3. 数据冷热分离
4. SQL 优化
5. 深度分页优化
6. 适当冗余数据
7. 使用更高的硬件配置

------

## 十、MySQL读写分离

### 1. 什么是读写分离？

读写分离是为了将**对数据库的读写操作分散到不同的数据库节点**上，一般情况下会选择一主多从，也就是一台主数据库负责写，其他多个从数据库负责读。主库和从库之间会进行数据同步保证数据的一致性

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716926666156-00feb302-2a38-4078-bd83-0927114b2063.png)



### 2. 如何实现读写分离？

一般通过引用第三方组件来帮助完成读写请求，比如`sharding-jdbc`。

### 3. 主从复制的原理？

在MySQL中主从复制一般依赖于binlog实现。binlog**主要记录了MySQL数据库中数据的所有变化，**即数据库执行的所有DDL和DML语句。

**主从复制的具体过程：**

1. 主库将数据库中数据的操作写入到**binlog**；
2. 从库连接主库，并且创建一个I/O线程向主库请求更新的binlog；
3. 主库会创建一个binlog dump线程来发送binlog，从库中的I/O线程负责接收binlog；
4. 从库的I/O线程将接收的binlog写入到relay log中，从库的SQL线程读取relay log，执行SQL同步数据到本地。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716937738322-e07bdd3a-34ae-4e21-8871-c9d8715fa229.png)

### 4. 什么是主从延迟？为什么出现主从延迟？（什么场景下出现主从延迟？

主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的**主从同步延迟** 。



MySQL主从同步延时是指从库的数据落后于主库的数据，这种情况的根本原因是两个方面：

1. 第一个方面，从库I/O线程接收binlog的速度跟不上主库写入binlog的速度，导致从库relay log的数据总是滞后于主库binlog的数据；
2. 第二个方面，从库SQL线程执行relay log的速度跟不上从库I/O线程接收binlog的速度，导致从库的数据滞后于从库relay log的数据。

**主从延迟直接原因**

1. **从库机器性能比主库差**：从库接收binlog并写入relay log以及执行SQL语句的速度会比较慢（也就是 T2-T1 和 T3-T2 的值会较大），进而导致延迟。解决方法是选择与主库一样规格或更高规格的机器作为从库，或者对从库进行性能优化，比如调整参数、增加缓存、使用 SSD 等。
2. **从库处理的读请求过多**：从库需要执行主库的所有写操作，同时还要响应读请求，如果读请求过多，会占用从库的 CPU、内存、网络等资源，影响从库的复制效率（也就是T2-T1和T3-T2的值会较大，和前一种情况类似）。解决方法是引入缓存（推荐）、使用一主多从的架构，将读请求分散到不同的从库，或者使用其他系统来提供查询的能力，比如将binlog接入到Hadoop、Elasticsearch等系统中。
3. **大事务**：运行时间比较长，长时间未提交的事务就可以称为大事务。由于大事务执行时间长，并且从库上的大事务会比主库上的大事务花费更多的时间和资源，因此非常容易造成主从延迟。解决办法是避免大批量修改数据，尽量分批进行。类似的情况还有执行时间较长的慢 SQL，实际项目遇到慢 SQL应该进行优化。

### 5. 如何避免主从延迟？

1. 如果某个业务一定需要使用最新更新的数据，那就强制将读请求路由到主库处理；
2. 延迟读取，没办法完全避免主从延迟，只能说可以减少出现延迟的概率。比如延迟时间是0.5秒，那就1秒后再发起读请求

------

## 十一、MySQL分库分表

### 1. 什么是分库？

**分库**指的是**将数据库中的数据分散到不同的数据库上**，一般有垂直分库与水平分库。

**垂直分库**就是**单一数据库按照业务进行划分**，不同的业务使用不同的数据库，将一个数据库的压力分散到多个数据库。举个例子：将数据库中的用户表、订单表和商品表分别单独拆分为用户db、订单db和商品db。

**水平分库**是指**同一个表按一定规则拆分到不同的数据库中**，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。比如订单表数据量太大，对订单表进行了水平分表，然后将切分后的 2 张订单表分别放在两个不同的数据库。

### 2. 什么是分表？

**分表**就是对单表的数据进行拆分，**可以是垂直拆分，也可以是水平拆分**。

**垂直分表**是对数据表列的拆分，**把一张列比较多的表拆分为多张表**，比如可以将用户信息表中的一些列单独抽出来作为一个表。

**水平分表**是对数据表行的拆分，**把一张行比较多的表拆分为多张表**，比如我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。

### 3. 什么情况下需要分库分表？

1. 数据库中的数据占用的空间越来越大，备份时间越来越长，可以进行分库；
2. 单表的数据达到千万级别以上，数据库读写速度比较缓慢，可以进行分表；

### 4. 分库分表会带来哪些问题？

**事务问题**：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。这个时候，我们就需要引入分布式事务了。

### 5. 常见的分片算法有哪些？

- 

分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。

常见的分片算法有：

- **哈希分片**：求指定分片键的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。哈希分片可以使每个表的数据分布相对均匀，但对动态伸缩（例如新增一个表或者库）不友好。
- **范围分片**：按照特定的范围区间（比如时间区间、ID 区间）来分配数据，比如将id为1~299999的记录分到第一个表， 300000~599999的分到第二个表。范围分片适合需要经常进行范围查找且数据分布均匀的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。
- **映射表分片**：使用一个单独的表（称为映射表）来存储分片键和分片位置的对应关系。映射表分片策略可以支持任何类型的分片算法，如哈希分片、范围分片等。映射表分片策略是可以灵活地调整分片规则，不需要修改应用程序代码或重新分布数据。不过，这种方式需要维护额外的表，还增加了查询的开销和复杂度。
- **一致性哈希分片**：将哈希空间组织成一个环形结构，将分片键和节点（数据库或表）都映射到这个环上，然后根据顺时针的规则确定数据或请求应该分配到哪个节点上，解决了传统哈希对动态伸缩不友好的问题。

------

## 十二、MySQL 数据库表设计

### 1. 多对多表怎么设计的？





### 2. 讲讲你设计过的数据库表结构，是如何体现三范式的？

**第一范式**

对于一张用户信息表，中有一个地址字段，但是地址字段是可以被拆分为省、市、街道等等，

**第二范式**： 1NF 基础上，非主键字段对主键不存在部分函数依赖

对于一张学生信息表，有学号、姓名、年龄、课程号、课程分数等字段，学生的学号决定姓名、年龄，学号和课程号共同决定课程分数，因此（学号，课程号）是表的联合主键。但姓名、年龄只和学号有关，因此存在部分函数依赖，因此实际表数据也会大量重复，违反第二范式。需要将学生信息和考分拆成 2 张表。

插入、删除异常

数据冗余

**第三范式：**2NF基础上，不存在属性对主键的传递依赖**
**假设现有员工信息表，表里有字段员工工号，员工职级，员工薪资，员工工号对应于职级，职级决定薪资，因此薪资对员工工号存在传递依赖。

插入、删除异常

### 3. 数据库的主键为什么要用自增？

1. 简单易用：数据库自己管理主键的创建和自增，不需要开发人员去编写处理主键的逻辑
2. 性能优势：自增主键保证了数据存储的顺序性，提高了查询的性能。
3. 唯一性：数据库会自动保障主键唯一，不会重复



------

## 十三、场景题

### 1. SELECT * FROM t_order ORDER BY id LIMIT 1000000, 10这条语句怎么优化？

变成SELECT * FROM t_order WHERE id > 1000000 ORDER BY id LIMIT 10;

### 2. 给你张表，发现查询速度很慢，你有那些解决方案

### 3. 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？

我们平时写Sql时，都要养成用explain分析的习惯。慢查询的统计，运维会定期统计给我们

优化慢查询思路：

参考：慢查询如何优化？

### 4. 随着业务推进，数据库中数据越来越多，怎么优化？

1. **索引优化****
   **为高频查询的字段添加索引，索引可以显著减少扫描数据的时间
   涉及多个字段，创建联合索引
2. **查询优化****
   **避免在查询中使用 SELECT *，而是明确指定所需字段。
   减少复杂的嵌套查询，尽可能使用简单的 JOIN 或子查询。
3. **分库分表**

1. 水平分区（Sharding）：将表中的数据按某个字段划分到多个物理表中，以减少每个查询的扫描范围。常见的分区方式有按时间、按地理位置、按 ID 等方式进行分片。
2. 垂直分区：将表中的字段按照访问频率和类型划分为多个表，减少查询时不必要的数据读取。例如，将较为静态的用户基本信息和频繁更新的交易记录分开存储。

1. **读写分离****
   **采用主从复制架构，将写操作集中在主库上，通过负载均衡技术将读请求从库，减轻主库压力。

### 5. 存入数据到数据库有哪些加速手段？

1. **使用批量插入**，减少与数据库的交互次数
2. 数据库连接池
3. 优化数据表，尽量少建索引（尤其是唯一索引）
4. 换一个存储引擎，InnoDB综合性较强，为了插入可以

### 6. MySQL处理百万级数据怎么优化？