## 线程

### 1. 什么是进程？什么是线程？它们之间有什么区别？

进程是程序的个实例，是**系统分配资源的基本单位**，运行一次程序对应了进程的创建，运行和销毁。
线程是比进程更小的执行单位，**一个进程在执行过程中可以产生多个线程**。

**区别**

1. 一个线程只能属于一个进程，但是一个进程可以包含多个线程
2. 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存
3. 进程是资源分配的基本单位，线程是CPU调度的最小单位
4. 进程切换的开销也远大于线程切换的开销
5. 进程之间相互隔离，进程崩溃不会影响别的进程，线程崩溃可能影响整个进程

### 2. 知道协程吗？

协程是比线程更轻量级的并发机制，一个线程中可以运行多个协程，并且它们不需要操作系统的**线程调度器**来管理，也不需要上下文切换的开销。协程采用非阻塞 I/O，等待 I/O 操作时挂起自己，不占用 CPU 资源，从而提高资源利用率。一般 go 程序开发用到协程比较多

### 3. (高频) Java 中有哪几种方式来创建线程？

1. 继承 Thread 类，重写 run() 方法；
2. 实现 Runnable 接口，重写 run() 方法；
3. 通过实现 Callable 接口并重写 call() 方法，再结合 Thread 和 FutureTask 的使用，可以支持获取异步执行任务的结果；
4. 使用线程池创建和管理线程。

### 4. (中高频) 可以直接调用 Thread 类的 run() 方法吗？

创建一个线程后，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当**分配到时间片后**就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

### 5. Runnable 和 Callable 的区别？

1. Runnable 接口的 run 方法无返回值，Callable 接口 call 方法有返回值，并且可以与Future接口、 FutureTask 类配合使用，来获取异步执行的结果；
2. run 方法的异常只能在方法内部处理，不能向外抛出，call 方法可以抛出异常。

### 6. Future和FutureTask的区别？

1. **Future
   **Future 表示一个异步任务的结果，可以用于查询任务的状态、取消任务以及得到任务的结果，Future 一般和线程池一起使用。
2. **FutureTask
   **FutureTask可以作为一个任务提交给线程或线程池执行，也可以用来查询任务的状态和结果。

### 7. 创建线程数过多或过少的后果？创建多少个线程合适？

1. **CPU 密集型任务(N+1)：** 消耗的主要是CPU资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
2. **I/O 密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

N 表示 CPU 的核心数

### 8. 通用的线程生命周期？

1. **初始状态：**

1. 线程仅仅在编程语言层面被创建，在操作系统中并没有被创建，因此还不能被分配 CPU 资源；

补充：相当于现在只是在 Java 中 new 了个 Thread 对象，还没调用 start() 方法。

1. **可运行状态：**

1. 真正的**操作系统线程此时已经成功被创建**，线程已经可以被分配 CPU 资源了。

1. **运行状态：**

1. 当有空闲的 CPU 资源时，操作系统会将其分配给一个处于可运行状态的线程，可运行状态的线程一旦被分配的 CPU，它的状态将变为运行状态。

1. **休眠状态：**

1. 运行状态的线程如果调用了某个阻塞式 API（如以阻塞方式读文件），那么这个线程将变为休眠状态，并放弃自己的 CPU 使用权；
2. 当它的阻塞状态结束了，它的状态会变为可运行状态，等待再次被分配 CPU 资源。

1. **终止状态：**

1. 当线程执行完或出现异常时，它就会进入终止状态，这是一个终态（只进不出的饕餮状态），就是挂了。

### 9. (中高频) Java线程生命周期？

Java 线程的生命周期将通用线程周期模型中的运行和可运行合二为一，又将休眠状态细分为阻塞、等待、超时等待。

1. NEW: 初始状态，线程被创建出来但没有被调用 start() 。
2. RUNNABLE: 运行状态，线程被调用了 start() 等待运行的状态；也可能已经被分配资源正在运行
3. BLOCKED：阻塞状态，线程正在等待一个同步锁，而锁被其他线程持有，需要等待锁释放后自动唤醒。
   WAITING：等待状态，表示该线程需要等待其他线程显式地通知它，如notify()方法。
   TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
4. TERMINATED：终止状态，表示该线程已经运行完毕。

**WAITING**

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725479483431-335bf0ee-623c-427e-a593-a97108d6b5b3.png)

**TIMED_WAITING**

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725479533886-5c24a5da-0f38-49e9-a9ac-94aa28e3be7f.png)

### 10. 带参 wait 方法到时间之后会做什么？

wait 在线程超时后唤醒时，并不会立即执行代码，它需要重新获取对象的监视器锁，才能继续执行后续的代码。如果该锁在超时后被其他线程持有，唤醒的线程进入**阻塞状态**，直到锁被释放。

### 11. 操作系统线程和Java线程的关系？

Java 线程是操作系统线程的高级抽象，现代 JVM 通常将每个 Java 线程直接映射到一个操作系统线程，从而充分利用操作系统提供的并发和调度能力。

### 12. 让一个线程进入阻塞态有哪些方法？

1. synchronized 块或者方法
2. ReentrantLock 锁
3. wait() 被唤醒之后会先尝试获取锁，获取不到就进入Blocked状态

### 13. 如何暂停一个线程？

1. **使用 Thread.sleep(long millis)**：使当前线程暂停执行指定的毫秒时间，在指定时间后，线程会继续运行。
2. **使用 Object.wait()**：wait() 方法是基于对象锁的一种机制，线程进入等待状态，直到调用 notify() 或 notifyAll() 被唤醒。线程必须持有对象的锁，才能调用 wait()，这通常用于线程同步。
3. 使用 LockSupport.park() 和 unpark()：不需要对象锁，更加灵活。
4. join() 方法让一个线程等待另一个线程执行完毕后再继续运行。

### 14. 说说 sleep() 方法和 wait() 方法的区别？

两者都可以暂停线程的执行。

1. sleep() 是 Thread 类的静态本地方法，wait() 则是 Object 类的本地方法。
2. sleep() 方法没有释放锁，而 wait() 方法释放了锁 。
3. wait() 通常被用于线程间交互/通信，需要在 synchronized 代码块中使用，sleep() 通常被用于暂停执行。
4. wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。
   sleep() 方法执行完成后，线程会自动苏醒。

### 15. Java 中 sleep() 方法会一直占用 cpu 吗？wait() 方法会占用 cpu 吗？

两者都会**释放 CPU 资源**，等待条件满足后再重新竞争 CPU 时间片。

调用 sleep() 后进入 TIME_WAITING 或 BLOCKED 态

调用 wait() 后进入 WAITING 或 TIME_WAITING 态

### 16. 什么叫守护线程？守护线程不结束怎么办？

守护线程主要用于辅助用户线程的工作，生命周期取决于用户线程的生命周期。如果所有的用户线程结束了，守护线程也会自动终止。

------

## 多线程

### 1. (中高频) 并发和并行的区别？

1. **执行方式：
   **并发通过任务调度和 CPU 时间片轮转，使多个任务在同一时间段内交替进行。
   并行通过多处理器或多核处理器，使多个任务在同一时刻同时进行。
2. **资源共享**：
   并发时任务之间共享资源，需要同步机制管理资源访问
   并行时任务通常在独立的处理器或核心上运行，资源独立
3. **应用场景：
   **多任务交替
   大量计算任务

### 2. 什么是同步？什么是异步？

同步与异步的区别主要体现在**访问数据的机制**不同，同步需要等待，异步不需要等待。

1. 同步主动请求数据并等待 IO 操作完成，如果结果没有返回，则一直等待。
2. 异步则指主动请求数据后可以继续处理其它任务，不用等待返回结果，调用直接返回。

### 3. 为什么使用多线程？单线程模型存在的缺点？

1. 从计算机底层来说，多核 CPU 的架构意味着多个线程可以同时运行，这减少了线程上下文切换的开销；
2. 从软件开发角度来说，使用多线程可以提升系统整体的并发能力以及性能。

单线程模型可能在以下方面存在一些缺点：

1. **无法处理高并发**
   单线程模型一次只能执行一个任务，每个任务必须顺序执行，一个任务执行时另一个任务会被阻塞。Web 服务器或者消息处理系统，高并发场景下效率较低。
2. **阻塞I/O问题
   **单线程中如果有 I/O 会导致线程阻塞，其他的线程任务得不到处理
3. **无法充分利用多核 CPU：**单线程模型只能使用一个 CPU 核心，无法利用现代多核处理器的优势。
4. **响应性差：**当单线程处理大量计算任务或复杂的长时间操作时，响应速度会显著下降

### 4. 使用多线程会带来什么问题？

可能会带来内存泄露、死锁、线程不安全等问题。

内存泄露

使用线程池`ThreadPoolExecutor`的时候没有正确地关闭线程池，导致线程一直存在，从而占用大量的内存

死锁

### 5. 如何理解线程安全？什么是线程不安全？

1. 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
2. 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

### 6. 单核 CPU 上运行多个线程效率一定会变高吗？

首先，在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 时间片分配。单核 CPU 同时运行多个线程的效率是否会高，取决于线程的类型和**任务的性质**：

1. **CPU 密集型**：CPU密集型的线程主要进行**计算和逻辑处理**，需要占用大量的CPU资源，多核更好并行计算
2. **IO 密集型**：IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，线程可能会因为等待 I/O 操作而进入**阻塞状态**。多线程能够在一个线程等待时，切换执行其他线程的任务，最大化 CPU 的利用率

如果线程是 CPU 密集型的，那么多个线程同时运行会导致频繁的线程切换，增加了系统的开销，降低了效率。

如果线程是 IO 密集型的，那么多个线程同时运行可以利用 CPU 在等待 IO 时的空闲时间，提高了效率。

### 7. 线程发生上下文切换时要做哪些事情？

1. 保存当前线程的状态
   把寄存器值、程序计数器、栈指针保存到线程控制块 TCB，以便于后续可以直接执行
   寄存器存储：当前操作的指令；内存地址；计算中间值等等
2. 更新调度器数据结构
   操作系统的调度器会标记当前线程为“可被调度”或“阻塞”，选择下一个线程作为待运行的线程
3. 恢复新线程
   把下一个线程 TCB 中的信息恢复到 CPU 当中，包括寄存器、程序计数器、栈指针等
4. 更新内存管理单元
   更新内存管理单元（MMU）的**页表**，以映射新进程的虚拟地址空间到物理地址空间。

### 8. 线程上下文切换是什么？发生的原因是什么？

上下文一般指 CPU 寄存器和程序计数器中的内容。

线程上下文切换指操作系统**保存当前线程的上下文**，留待线程下次占用CPU的时候恢复现场，**加载下一个将要占用CPU的线程的上下文**。

1. 主动让出 CPU，比如调用了 sleep(), wait() 等。
2. 时间片好耗尽，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死，会分配固定时间片。
3. 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
4. Java 虚拟机垃圾回收导致。

### 9. Java 中加锁有哪些方式？

1. 内置锁：synchronized 关键字实现，使用简单，但是效率低；
2. 可重入锁：ReentrantLock，支持公平和非公平锁，比 synchronized 更灵活；
3. 读写锁：ReadWriteLock，允许多个读线程同时访问，但写线程被独占
4. 乐观读锁：StampedLock，乐观读锁，效率高。

### 10. 说说读写锁 ReadWriteLock？

读写锁基本原理

1. 读锁：多个线程可以同时获取读锁，并发读取数据；但是一个线程获取读锁读数据的时候，别的线程不可以获取写锁
2. 写锁：一个线程获取写锁之后，别的线程既不可以实现读锁，也不可以实现写锁

读写锁适用于**读多写少**的场景

缓存系统：多个线程可以同时读取缓存数据，但只有一个线程能够更新缓存。

**ReentrantReadWriteLock** 是 ReadWriteLock 的具体实现。

### 11. 说说 StampedLock？

三种锁模式：写锁，读锁、乐观读锁，通过不同的锁应对不同并发场景

1. 写锁：写锁是独占锁，只有一个线程获取写锁，其他线程等待写锁释放
2. 读锁：多个线程可以同时获取读锁，读锁共享，但是读写不共享
3. 乐观读：线程在读操作时不阻塞其他线程进行写，之后通过验证锁的戳（stamp）是否变更，确认读取期间数据是否发生了变化。

------

## 线程池

### 1. (中高频) 什么是线程池？为什么使用线程池？

线程池是管理一系列线程的资源池。

使用线程池的好处：

1. **降低资源消耗**：通过重复使用已创建的线程减少创建、销毁线程造成的资源消耗。
2. **提高响应速度：**当任务到达时**，**任务可以不用等待线程创建就能立即执行
3. **提高线程可管理性：**线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 2. 怎么创建一个线程池？怎么使用线程池

1. **创建线程池**：用上面的策略

1. 通过ThreadPoolExecutor构造函数来创建
2. 通过Excutors工具类类创建，Excutors提供了各种类型的线程池，最常见的包括

1. SingleThreadExecutor：只有一个线程的线程池
2. FixedThreadPool：固定线程数量的线程池
3. CachedThreadPool：可根据实际情况调整线程数量的线程池。
4. ScheduledThreadPool：给定的延迟后执行任务或定期执行任务

1. **提交任务**：通过 executor.submit(task) 提交任务，线程池中的线程将并发执行任务。
2. **关闭线程池**：任务提交完成后，调用 executor.shutdown() 关闭线程池。

**线程池管理：**

1. shutdown()：平滑关闭线程池，等待已提交的任务完成，不再接受新任务。
2. shutdownNow()：尝试停止所有正在执行的任务，并立即关闭线程池。

### 3. **为什么不建议使用 Executors 来创建线程池？产生什么问题？如何避免？**

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
    return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>());
}
```

创建的队列为`LinkedBlockingQueue`，是一个无界阻塞队列。在高负载情况下，如果任务提交到队列的速度超过了线程池处理它们的速度，队列将持续增长，占用越来越多的内存。最终，这可能导致内存耗尽，进而引发 OutOfMemoryError（OOM）错误。

为了避免这种情况，可以考虑以下几种策略：

1. 使用有界队列，如 ArrayBlockingQueue，限制队列大小。
2. 调整线程池大小和任务处理策略，以更高效地处理任务。
3. 对提交到队列的任务数量进行监控和控制，防止过载。

### 4. **线程池有哪几种状态？每种状态分别表示什么？**

1. RUNNING：表示正常运行，线程池可以接受新任务，也可以处理阻塞队列中的任务。
2. SHUTDOWN：调用线程池`shutdown()`方法时，线程池不接受新任务，但可以处理阻塞队列中的任务。
3. STOP：调用线程池`shutdownnow()`方法时，线程池不接受新任务，不处理阻塞队列中的任务，同时会中断正在执行的任务。
4. TIDYING：线程池中没有线程在运行后，工作线程数为零，状态变为 TIDYING，线程池会调用`terminated()`。
5. TERMINATED：`terminated()`方法执行完毕后，线程池状态变为TERMINATED。

### 5. (中高频) 讲讲线程池参数？

1. **corePoolSize :** 核心线程的数量，**任务队列的任务数量未达到队列容量时**，最多可以同时运行的线程数量。
2. **maximumPoolSize :** **任务队列中存放的任务达到队列容量的时候**，当前最多可以同时运行的线程数量。
3. **workQueue:** 任务队列，新任务来的时候**会先判断当前核心线程数是否已满**，如果已满，新任务就会被存放在队列中。
4. **keepAliveTime**: 线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，多余的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime 才会被回收销毁。（![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725592067208-0d3b20af-c41f-434e-9e7f-dce234ff93f2.png)
5. **unit** : keepAliveTime 参数的时间单位。
6. **threadFactory** :executor创建新线程的时候会用到。
7. **handler** :饱和策略。

### 6. 为什么需要核心线程，他的设计目的？

1. 提高效率，避免资源开销
2. 提升响应速度，保证最低并发度
3. 结合工作队列可以减少创建的线程数

### 7. 线程池的核心线程会被回收吗？

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725592067208-0d3b20af-c41f-434e-9e7f-dce234ff93f2.png?x-oss-process=image%2Fformat%2Cwebp)

### 8. 线程池的饱和（池满）策略有哪些？举例说明何时使用？

如果队列已经被放满了任务并且运行的线程数达到最大线程数时，有四种饱和策略

1. **ThreadPoolExecutor.AbortPolicy：****抛出异常**`RejectedExecutionException`来拒绝新任务的处理。
   实时性要求高的**金融交易系统**，如果无法处理新任务，应立即抛出异常进行告警和处理。
2. **ThreadPoolExecutor.CallerRunsPolicy：****调用执行自己的线程运行任务**，也就是直接在调用execute方法的线程中运行被拒绝的任务。
   **日志处理系统**，任务延迟处理影响不大，可由提交线程直接执行。
3. **ThreadPoolExecutor.DiscardPolicy：**不处理新任务，**直接丢弃**。
   对无法处理的任务可直接忽略，不影响系统主要功能。
4. **ThreadPoolExecutor.DiscardOldestPolicy：**此策略将**丢弃最早的未处理**的任务请求。
   **图片缓存更新任务**，较旧的缓存更新任务可丢弃，优先处理新的。

### 9. 为什么不允许丢弃任务，应该选择哪个拒绝策略？

### 10. CallerRunsPolicy 拒绝策略有什么风险？如何解决？

### 11. 线程池常用的阻塞队列？

新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

**有界队列**（如 ArrayBlockingQueue）：设置固定大小的队列，可以防止任务数量无限制增长。

**无界队列**（LinkedBlockingQueue，容量为 Integer.MAX_VALUE），一般用在 `FixedThreadPool`（核心线程和最大线程数量相等）和`SingleThreadExcutor`（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。

**直接提交队列**（SynchronousQueue），一般用在`CachedThreadPool`，不用于存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，CachedThreadPool 的最大线程数是 Integer.MAX_VALUE ，可以理解为线程数是可以无限扩展的。

**延迟阻塞队列**（DelayedWorkQueue）：`ScheduledThreadPool`和`SingleThreadScheduledExecutor`。DelayedWorkQueue 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。DelayedWorkQueue 添加元素满了之后会自动扩容原来容量的 1/2，即永远不会阻塞，最大扩容可达 Integer.MAX_VALUE，所以最多只能创建核心线程数的线程。

### 12. 线程池处理任务的流程？

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1725591359310-b0d54a1e-86cf-4d4e-9f4e-7136647146a6.png)

### 13. 线程池中的线程异常后，销毁还是复用？

### 14. 讲讲调度线程池 ScheduledThreadPoolExecutor

### 15. 线程池和ThreadLocal一起用会有什么问题吗？

1. **数据泄露问题：
   **任务 A 设置了一个值到 ThreadLocal，但没有清理；当任务B使用同一个线程时，它可能会读到任务A 的脏数据。
2. 内存泄露：
   中使用的 key 为 ThreadLocal 的弱引用，而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。
3. 无法保证隔离性：
   在线程池中，线程会被复用，不同任务可能共享同一个线程

### 16. 如何设定线程池的大小？

1. **CPU密集型任务**：如数学运算、数据处理，线程的数量应当尽量与CPU核心数匹配，以最大化CPU利用率，避免过多的线程上下文切换。
   线程数 = CPU核心数 + 1
   +1的原因：线程在执行过程中可能会因为某些系统调用而被短暂阻塞，比如内存访问、日志记录、或者与操作系统的交互，多出的一个线程可以在此期间使用CPU
2. **I/O密集型任务**：如文件读写、网络通信等。系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将CPU交出给其它线程使用。
   线程数 = CPU核心数 * 2

### 17. 在不考虑程序运行效率的情况下，能否无限制新建线程？

1. 内存限制：线程创建需要分配栈空间，不断分配新线程会导致 OOM，因此线程数不能无限制上涨
2. 操作系统限制：不同的操作系统对单个进程可以创建的线程数量有不同的上限

------

## 乐观锁和悲观锁

### 1. 什么是悲观锁？什么是乐观锁？

乐观锁或悲观锁都不代表具体的锁，而是两种设计锁的思想。

悲观锁总是假设最坏的情况，认为共享资源只要被多个线程访问就会出现并发安全问题，所以每次线程在获取资源时都会上锁。这样其他线程在想要获取资源时就会被阻塞，直到上一个持有者释放。



乐观锁总是假设最好的情况，认为共享资源每次被访问不会出现问题，线程无需加锁也无需阻塞，只有在**提交修改**时去验证对应的资源是否已经被其它线程修改过。

在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。在线文档，git 都是使用乐观锁的思想。

### 2. 说说[版本号机制](https://www.yuque.com/augustxun/yrct83/1a9a671bb1da8c030da96f67497751c7#版本号机制)实现乐观锁的原理？

一般是在数据表中加上一个数据版本号`version`字段，表示数据被修改的次数，当数据被修改时version 值会加一。假设线程 A 要执行更新数据的业务，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 version 值相等时才提交更新，否则重新读取该数据，直到成功。

### 3. 说说CAS机制？

CAS是一种通过**硬件指令级别的原子操作**来实现并发控制的机制，是乐观锁的思想
CAS 操作涉及三个操作数：内存位置、预期值、新值。当线程执行CAS 操作时，它会检查内存位置的当前值是否等于预期值：

如果相等，则将内存位置的值更新为新值，操作成功。

如果不相等，则操作失败，表明在此期间有其他线程更新了这个值。

因为CAS是通过硬件层面原子操作保证线程安全，无锁，所以通常具备更好的性能。



**统计一个接口的调用次数的时候，往往是采用AtomicInteger**？

他的底层是CAS乐观锁
为什么明明是高并发互斥写操作却选用乐观锁呢

理论上CAS更适合读多写少的场景，是因为互斥写的场景会导致频繁自旋；但对于接口调用统计来说，写操作的耗时非常低，这种场景下自旋操作的性能影响要远低于线程阻塞再唤醒的性能消耗

### 4. 乐观锁的优缺点？

优点

乐观锁在数据操作时不加锁，减少锁的争用，因此很适用于读多写少的场景，冲突不频繁情况下优势明显。

缺点：

1. 多个线程尝试写数据时只有一个可以成功，效率低下，因此不适合写频繁的场景
2. CAS 算法获取锁失败后会频繁自旋重试，消耗系统性能
3. 只能解决更新数据冲突这类问题，不能解决共享资源竞争等问题

------

## JMM

### 1. 什么是可见性问题？解决可见性问题？

JMM 定义了线程之间共享变量的访问规则

**本地缓存**：每个线程在执行过程中，可能会将共享变量的值保存在 CPU 寄存器或线程的本地缓存中，而不是每次都直接从主内存读取或写入。这意味着一个线程在本地缓存中修改了某个共享变量的值，其他线程可能仍然读取的是旧值。

**解决方案**

1. volatile
   虽然 volatile 关键字可以很好保证变量可见性，但是 volatile 无法保证线程操作的原子性
2. 使用线程安全的集合类
3. 使用 synchronized

### 2. 什么叫线程操作的原子性？

**线程操作的原子性**是指在多线程环境中，某个操作要么全部完成，要么根本不执行，没有中间状态或部分执行的情况。原子操作是不可分割的单个操作，其他线程不能中断它或看到它执行过程中未完成的部分。

### 3. 指令重排序问题？举个例子？

上层 Java 代码可能在底层对应了多条指令，编译器和处理器会对指令进行重排序以优化性能。这种重排序在单线程中通常不会改变程序的语义，但在多线程环境中可能会发生意向不到的结果。

**举例**

懒汉式的单例模式中，

------

## volatile

### 1. (高频) 说说 volatile 的作用？如何实现？

1. 保证可见性：对于一个 volatile 关键字修饰的变量，某一个线程对 volatile 变量写入后，要立即把最新值刷新到主内存中，读取时线程要清空本地缓存，从主存中读取最新值。
2. 禁止指令重排：底层使用的是**内存屏障指令**，它使得 CPU 或编译器在对内存进行操作的时候，严格按照一定的顺序来执行，保证内存屏障之前或之后的指令不会由于系统优化等原因导致乱序。

------

## synchronized

### 1. (中高频) 说说 synchronized 是什么？

synchronized 是 Java 中的一个关键字，**主要解决的是多个线程之间访问资源的同步性**，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

### 2. synchronized 是如何保证线程安全？

synchronized 是 Java 的关键字，一般用来修饰方法或代码块，保证线程安全主要依赖于三个方面：

1. **互斥性**
   当一个线程进入一个 synchronized 修饰的方法或代码块时会自动获得锁。此时别的线程想要访问该方法或代码块会被阻塞，直到持有锁的线程执行完从而释放锁。如果修饰的是实例方法，锁住的是实例对象；如果修饰的是静态方法，锁住的是 Class 对象；修饰代码块会锁住括号的内容。
2. **可见性**
   根据 Java 内存模型（JMM），当一个线程退出一个同步块时，它立刻将在这个同步块中修改的变量的最新值刷写回主内存中。另一方面，当线程进入同步块时，它会看到由之前持有同一个锁的线程所做的所有写操作。
3. **有序性
   **编译器和处理器会进行指令重排来优化执行速度，而 synchronized 关键字会避免指令重排。原理是 JVM 在 synchroized 开始和结束的地方插入了内存屏障来避免指令重排。

### 3. 说说synchronized底层原理？

1. 修饰同步代码块，字节码层面使用的是 monitorenter 和 monitorexit 指令。

1. `monitorenter`指令指向同步代码块的开始位置，在执行 monitorenter 时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器加 1。
2. `monitorexit`指令指向同步代码块的结束位置，对象锁的的拥有者线程才可以执行 monitorexit 指令来释放锁。在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放，其他线程可以尝试获取锁。

1. 修饰方法（普通方法or静态方法），使用的是`ACC_SYNCHRONIZED`标识，该标识指明了该方法是一个同步方法。JVM通过标识来辨别一个方法是否是同步方法，从而执行相应的同步调用。如果是普通方法，会尝试获取实例对象的锁；如果是静态方法，会尝试获取当前class的锁。

总之，synchronized的本质是对**对象监视器monitor**的获取。

### 4. synchronized 修饰在哪些地方？

1. **修饰普通方法**

给当前对象实例加锁，进入同步代码前要获得**当前对象实例的锁** 。

```java
synchronized void method() {
    //业务代码
}
```

1. **修饰静态方法**

给当前类加锁，会作用于类的所有对象实例。

```java
synchronized static void method() {
    //业务代码
}
```

1. **修饰代码块**

对括号里指定的对象/类加锁：

- `synchronized(object)`表示进入同步代码块前要获得**给定对象的锁**
- `synchronized(类.class)`表示进入同步代码前要获得**给定Class的锁**

### 5. **实例锁和类锁的区别？**

**锁粒度**：

实例锁锁住的是具体的对象实例，多个线程可以访问不同实例的同步方法

类锁锁住的是整个类，多个线程必须按序访问静态同步方法

**使用场景：**

对象级别并发控制：银行账户，每个账户同步操作独立进行

类级别并发控制：计数器

### 6. (中高频) synchronized 锁升级的过程？

**偏向锁**：当锁刚开始使用时，JVM首先会默认将其设置为偏向锁，偏向锁的特点是：假设没有其他线程会尝试获取同一个锁。锁对象的对象头中会记录当前加锁的线程ID，支持锁重入，再次试图获取锁时不需要加锁/释放锁操作。
**轻量级锁**：如果另一个线程尝试获取同一个偏向锁，JVM会升级偏向锁到轻量级锁。轻量级锁通过在对象头上存储锁标记，而不是在操作系统层面进行同步。创建锁记录（Lock Record）对象，每个线程的**栈帧**都会包含一个锁记录的结构。让锁记录中Object reference指向锁住的对象，并尝试用 CAS 替换Object的Mark Word，将Mark Word的值存入锁记录。
**重量级锁**：如果有多个线程竞争同一个轻量级锁，会发生锁膨胀，JVM会将其升级为重量级锁。这时，为锁Object对象申请Monitor锁，**通过Object对象头获取到持锁线程**，将Monitor的Owner置为当前持锁线程。

### 7. **(中高频) synchronized 和 ReentrantLock 区别？各自使用场景？**

ReentrantLock是Java提供的一个可重入锁，它位于java.util.concurrent.locks包下

1. *用法不同*

synchronized可以用来修饰普通方法、静态方法和代码块，而ReentrantLock通过在代码块中手动加锁释放锁。

1. *获取锁和释放锁的机制*

synchronized**自动**加锁和释放锁，而 ReentrantLock需要**手动**加锁和释放锁。

1. *锁类型*

synchronized是非公平锁，而ReentrantLock默认为非公平锁，可以手动指定为公平锁。

1. *响应中断*

ReentrantLock可以响应中断，退出等待状态，并抛出 InterruptedException，从而避免死锁。
而synchronized不能响应中断，可能发生死锁。

1. *底层实现*

synchronized是JVM层面通过monitor实现的，而ReentrantLock是基于AQS实现的。

### 8. synchronized 和 volatile 的区别？

1. 性能上，volatile 关键字是线程同步的 轻量级实现，所以 volatile **性能** 肯定比synchronized关键字要好 。
2. 用法上，但是 volatile 关键字只能用于 **变量** 而 synchronized 关键字可以 **修饰方法以及代码块** 。
3. 作用上，volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。
4. 特点上，volatile 关键字能保证数据的 **可见性**，但不能保证数据的 **原子性**。synchronized 关键字两者都能保证。

------

## ReentrantLock

### 1. ReentrantLock是什么？

ReentrantLock实现了Lock接口，是一个**可重入且独占式**的锁，和 synchronized 关键字类似。但 ReentrantLock增加了轮询、超时、中断、公平锁和非公平锁等高级功能。

### 2. 公平锁和非公平锁的区别？

*公平锁* 

锁被释放之后，先申请的线程先得到锁。公平锁为了保证时间上的绝对顺序，上下文切换更频繁，性能较差一些。

*非公平锁*

锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序。性能更好，但可能会导致某些线程永远无法获取到锁。

------

## ThreadLocal

### 1. ThreadLocal有什么用？

ThreadLocal类让每个线程可以保存专属的本地变量。

### 2. ThreadLocal 有哪些应用场景？底层是如何实现的？

**应用场景：**

1. **存储用户身份验证信息**：在多线程环境下处理用户请求时，通常需要存储用户的身份信息（如用户 ID、用户名等），以便在整个请求处理过程中可以随时访问。ThreadLocal 可以用于将这些信息与当前线程绑定，从而避免线程间的干扰。
2. **数据库连接管理**：在数据库编程中，每个线程持有独立的数据库连接，使用 ThreadLocal 管理。
3. **存储会话信息**：在处理 Web 请求时，ThreadLocal 可以用于存储当前线程的会话信息
4. **跨类传递上下文信息：**有时我们需要在不同的方法或类之间传递上下文信息，而不希望将这些信息作为参数传递。这种情况下，ThreadLocal 可以作为一个全局的存储方式，允许线程安全地跨越方法和类边界传递数据。

**底层实现：**
ThreadLocal 的底层是通过 ThreadLocalMap 实现的，当去调用 ThreadLocal 的 set 方法时，实际上是将数据存储在当前线程的 threadLocals 字段中，这些本地变量只对当前线程可见。这种方式确保了每个线程访问自己的独立变量，从而实现了线程隔离。ThreadLocalMap 中键是 ThreadLocal，值是 Object 对象。

但是可能存在内存泄漏问题，当 ThreadLocal 中的数据没有被使用时，需要调用 `remove()` 方法进行垃圾回收。

### 3. ThreadLocal 内存泄露问题怎么导致的？

ThreadLocalMap 中使用的 key 是弱引用，而value是强引用。所以，如果ThreadLocal没有被外部强引用的情况下，在垃圾回收的时候，key会被清理掉，而value不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。使用完 ThreadLocal 方法后最好手动调用 remove() 方法，防止内存泄露。

### 4. ThreadLocal 跨线程失效怎么办？

1. 使用 InheritableThreadLocal 传递数据给子线程
2. 用 TransmittableThreadLocal 在线程池中传递 ThreadLocal 数据给子线程使用

------

## AQS

AQS的全称是`AbstractQueuedSynchronizer`，翻译过来的意思就是抽象队列同步器。

### 简单说说AQS？

基本构成

AQS 通过一个状态变量（state）**和一个**等待队列（FIFO）来管理多个线程的同步操作：

**状态变量**：用于表示当前的同步状态。比如，在锁的场景下，状态变量可以表示锁是否被持有或被几个线程持有（在可重入锁的场景下）。

**等待队列**：当一个线程请求获取同步资源（如锁、信号量等）失败时，AQS 会将该线程加入到等待队列中，队列中的线程按 FIFO 排序，等待被唤醒后重新尝试获取资源。



两种模式

1. 独占模式：在独占模式下，只有一个线程可以获取到同步资源，其他线程必须进入等待队列
2. 在共享模式下，多个线程可以同时成功获取到同步资源。

------

## 原子类

### 1. 原子类的原理？

以AtomicInteger为例，AtomicInteger类底层主要利用CAS+volatile 和native方法来保证原子操作。如果使用基本数据类型，那么必须使用synchronized来维护线程安全性，因此使用原子类可以显著提升执行效率。

------

## 场景题

### 1. 多线程读写 Student 数组，如何实现？

这个问题可以拆解为两个步骤，第一步是保证Student数组的并发安全性，也就是避免发生数据并发安全问题，对此有4个方案：

**方案1** 使用`synchronized`关键字

`synchronized`关键字是悲观锁的思想，显式加锁，确保同一时间只有一个线程可以读或者写数组

```java
public class SafeArray {
    private final int[] array;

    public SafeArray(int size) {
        array = new int[size];
    }

    public synchronized void write(int index, int value) {
        array[index] = value;
    }

    public synchronized int read(int index) {
        return array[index];
    }
}
```

**方案2** 使用`ReentrantLock`

也是悲观锁，但是相对来说更灵活，支持尝试加锁，超时加锁

```java
import java.util.concurrent.locks.ReentrantLock;

public class SafeArray {
    private final int[] array;
    private final ReentrantLock lock = new ReentrantLock();

    public SafeArray(int size) {
        array = new int[size];
    }

    public void write(int index, int value) {
        lock.lock();
        try {
            array[index] = value;
        } finally {
            lock.unlock();
        }
    }

    public int read(int index) {
        lock.lock();
        try {
            return array[index];
        } finally {
            lock.unlock();
        }
    }
}
```

**方案3** 使用`ReadWriteLock`

可以实现读写分离，允许多个读线程同时访问，但写线程独占访问

```java
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class SafeArray {
    private final int[] array;
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public SafeArray(int size) {
        array = new int[size];
    }

    public void write(int index, int value) {
        rwLock.writeLock().lock();
        try {
            array[index] = value;
        } finally {
            rwLock.writeLock().unlock();
        }
    }

    public int read(int index) {
        rwLock.readLock().lock();
        try {
            return array[index];
        } finally {
            rwLock.readLock().unlock();
        }
    }
}
```

**方案4** 直接使用并发集合，如`CopyOnWriteArrayList`

```java
import java.util.concurrent.CopyOnWriteArrayList;

public class SafeArray {
    private final CopyOnWriteArrayList<Integer> array;

    public SafeArray(int size) {
        array = new CopyOnWriteArrayList<>(new Integer[size]);
    }

    public void write(int index, int value) {
        array.set(index, value);
    }

    public int read(int index) {
        return array.get(index);
    }
}
```