## 一、操作系统基础

### 1. 什么是操作系统？

操作系统是管理计算机硬件与软件资源的软件

从功能角度来看：

1. 进程管理：调度和分配计算机系统中的CPU资源给各个进程
2. 内存管理：合理分配和管理计算机的内存空间给应用程序，尽可能提高内存的利用率。
3. 文件管理：有效地管理、存储计算机中的文件资源，方便用户进行读写操作
4. 设备管理：对计算机的各种外部设备，如键盘、鼠标、打印机等进行管理和协调，使它们能够与计算机系统协同工作。
5. 提供用户接口：包括命令行界面和图形用户界面，使用户能够方便地与计算机进行交互和操作。

常见的操作系统有Windows、Linux、MacOS 等，不同的操作系统在性能、稳定性、安全性、易用性等方面各有特点，适用于不同的应用场景和用户需求。

### 2. 操作系统内核和CPU的区别？

操作系统的内核（Kernel）属于操作系统层面，而CPU属于硬件层面。

1. CPU主要提供运算，处理各种指令的能力；
2. 内核（Kernel）主要负责系统管理比如内存管理、文件系统、应用程序管理等，它相当于应用程序和硬件的桥梁。内核与硬件交互的方式：

1. 系统调用：应用程序通过系统调用向内核发出请求，内核通过这些请求与硬件交互
2. 驱动程序：打印机、网卡、硬盘等都有相应的驱动程序，内核通过驱动程序与这些设备进行通信。
3. 硬件接口：CPU提供的特殊指令或寄存器来和硬件直接通信

### 3. (中高频) 什么是用户态和内核态？

用户态和内核态是操作系统中应用程序的两种不同执行模式，用于控制程序对计算机硬件资源的访问权限和操作范围，确保用户程序和系统内核隔离，系统资源的安全管理。“态”指的不是应用程序的状态，还是一种权限模式

1. 用户态
   只能直接读取用户程序的数据，拥有较低的权限。如果需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态。
2. 内核态
   可以访问计算机的任何资源包括系统的存储空间、设备、驱动程序等，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用并将结果返回给进程，最后再从内核态切换回用户态。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1711651406791-dd747423-1fcb-4c6a-86a9-0ab6016c6865.png)



### 4. 只有一个内核态不行么？

1. 在CPU的所有指令中，有一些指令是比较危险的比如**内存分配、设置时钟、I/O 处理**等，如果所有的程序都能使用这些指令的话，会对系统的正常运行造成不可控的影响。
2. 如果只有一个内核态，那么所有进程都必须共享系统资源，例如**内存、CPU、硬盘**等，这将导致系统资源的竞争和冲突，从而影响系统性能、安全性**。**

### 5. 用户态切换到内核态的方法？

1. 系统调用
   用户程序需要执行某些特权操作，比如文件读写、网络I/O操作等，于是向内核发出系统调用请求。
2. 硬件中断
   来自键盘、网卡、硬盘等通知CPU进行处理，系统会切换到内核态执行相应的中断处理程序。
3. 异常处理
   用户程序执行过程中出现了异常非法操作或错误，CPU自动切换到内核态执行异常处理程序

### 6. (中高频)讲一下你理解的虚拟内存？

**虚拟内存是一种操作系统技术，用于扩展和管理计算机内存的使用。**

1. **内存扩展**：
   虚拟内存允许程序使用比物理内存更大的地址空间。操作系统通过将不常用的数据临时存放到磁盘的交换空间中，腾出物理内存给活跃的程序使用。这确保了即使物理内存不够用，程序也可以继续运行。
2. **地址空间独立性**：
   每个进程可以使用独立的虚拟地址空间，而不用担心其他进程的内存。操作系统会将这些虚拟地址映射到物理地址，保证进程的隔离和独立性，这增强了系统的安全性和稳定性。
3. **分页机制**：
   虚拟内存通常通过**分页**来实现，内存被划分为等大小的**页**。当程序访问某个虚拟地址时，操作系统通过**页表**将虚拟地址转换为物理地址，并进行实际的内存操作。
4. **页面置换**：
   当物理内存不足时，操作系统会使用**页面置换算法**将不常使用的页面从物理内存移到磁盘上。这种机制通过选择较不活跃的页面进行置换来优化内存使用。

### 7. Linux 如何通过页实现内存管理的？

### 8. (中高频) 有哪些页面置换算法？

1. 先进先出
2. LRU 最久未使用
3. LFU 最少使用
4. OPT 选择未来最长时间不再使用的页面进行替换

### 9. 如何将虚拟地址转换成物理地址？

### 10. 发生了进程调度，如何确定一个进程的页表？

------

## 二、进程和线程

### 1. 有了进程为什么要线程？

1. 在一个进程中线程可以并发执行，充分利用多核CPU和计算能力
2. 主线程响应用户，异步线程执行后台操作，提升响应速度

### 2. Pcb和tcb保存了哪些信息？各自的作用？举例说明

### 3. 进程状态有哪些？说说进程状态模型的转换？挂起和阻塞的区别？

1. **进程状态**

1. 新建态
   进程刚被创建出来，还没有准备好执行需要进行初始化，即操作系统去分配必要的资源（内存、进程控制块PCB
2. 就绪态
   进程完成了初始化被放入就绪队列，等待操作系统的调度程序分配CPU
3. 运行态
   进程获得了 CPU 时间片并正在执行指令
4. 阻塞态
   运行中的进程由于等待操作进入阻塞状态，一般可能等待：

1. I/O操作（文件读写，网络I/O
2. 资源分配、锁或信号
3. 其他进程的事件（进程间通信

1. 终止态
   进程执行完毕或因异常情况被操作系统终止，进入终止状态



1. **状态转换**

1. 新建 → 就绪：进程初始化结束，进入就绪状态，等待操作系统调度程序分配CPU。
2. 就绪 → 运行：调度器为该进程分配CPU时间片，开始执行。
3. 运行 → 阻塞：进程等待某个外部事件（如 I/O 操作完成）时，进入阻塞状态。
4. 阻塞 → 就绪：当等待的事件（如 I/O 完成）发生时，进程返回到就绪状态，等待重新获得 CPU。
5. 运行 → 就绪：进程在时间片耗尽时，返回就绪队列，等待下一次调度。
6. 运行 → 终止：进程完成了任务或发生异常，进入终止状态。

1. **挂起态**

1. 定义：系统资源紧张时，会将部分进程的内存内容移动到磁盘，挂起的进程不参与CPU调度
2. 种类：

1. 就绪挂起态（进程在绪队列中，内容被从内存移动到磁盘）
2. 阻塞挂起态（进程在等待某个事件完成，被移动到磁盘

1. 挂起态和阻塞态区别：

1. 发生原因：挂起态发生原因是CPU为了优化对内存资源的使用；阻塞态是因为进程在等待某个事件完成
2. 内存占用：挂起态不占用内存；阻塞太一直占用内存

### 4. 知不知道什么状态下强制删除也删不掉的进程状态？

1. 僵尸进程

1. 定义：进程执行已经结束，但它仍然保留在**进程表**中，无法通过kill发送信号来处理
2. 原因：子进程终止，但父进程没有调用 wait() 系统调用来回收子进程的状态信息。
3. 解决方案：重新启动或终止父进程

1. 不可中断阻塞态

1. 定义/原因：等待磁盘I/O、网络I/O等低层操作系统资源引起的，进程被系统标记为状态D，无法强制删除，只有等待获得硬件资源和I/O操作完成，才可以从这种状态中恢复
2. 解决方案：通常需要等待进程自动恢复，时间太长就重启

### 5. 说说孤儿进程？

1. 定义/原因：父进程已经终止或退出，而它本身仍在继续运行的进程
2. 解决方案：由操作系统自动将孤儿进程的父进程设置为init，由init接管直到孤儿进程执行完毕

### 6. (高频) 进程之间的通信方式有哪些？

1. **管道/匿名管道**：是一种**半双工**的通信方式，数据只能单向流动，用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。
2. **有名管道**: 也是半双工的通信方式，有名管道可以让没有亲缘关系的进程之间互相通信 。
3. **信号量**：信号量是一种计数器，主要用于进程间的同步，控制对共享资源的访问。
4. **消息队列**：消息队列是消息的链表，存放在内核中由**消息队列标识符**标识。消息队列克服了信号量传递信息少、管道只能传输无格式字节流的缺点。
5. **共享内存**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更改。这是进程间效率最高的通信方式，一般和别的通信机制比如信号量配合使用，实现进程间的同步和通信。
6. **Socket套接字** : 套接字是一种通信端点，是TCP/IP网络通信的基本单元，主要用于客户端和服务器之间进行网络通信。

### 7. (中高频) 进程调度的算法有哪些？优缺点？

1. **先到先服务调度算法**: **从就绪队列中选择最先进入该队列的进程为之分配资源**，使它立即执行，并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
   优点：实现简单，便于理解
   缺点：可能导致等待时间长，不实用需要快速响应的系统
2. **短作业优先的调度算法** : **从就绪队列中选出一个估计运行时间最短的进程为之分配资源**，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
   优点：平均等待时间较低，因为短作业会优先完成
   缺点：1. 需要预先知道每个作业的执行时间；2. 可能导致长作业得不到执行。
3. **时间片轮转调度算法**: 每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
   优点：进程被均等分配时间片，实现公平调度，能防止进程饥饿
   缺点：时间片的选择很关键，如果时间片太大，系统响应时间变长；如果时间片太小，调度开销增大
4. **优先级调度算法**：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。
   优点：适用于某些任务有优先处理需求的场景
   缺点：可能导致低优先级的任务长时间得不到处理
5. **多级反馈队列调度算法**：多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
   优点：灵活性高，动态调整进程优先级，适用于不同类型作业
   缺点：实现复杂

### 8. (中高频) 解释一下进程的同步和互斥，以及如何实现进程同步和互斥？

### 9. (高频) 什么是死锁？列举一个操作系统发生死锁的例子？死锁产生的条件？

死锁是指两个或多个进程或线程在争夺系统资源时，由于互相等待对方释放资源而阻塞，导致程序无法继续执行的状态。

**举例**：进程A占用资源X并且请求资源Y，而进程B已经占用了资源Y并请求资源X。两个进程都在等待对方释放资源，陷入了死锁状态。

**死锁产生的四个条件：**

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个线程因请求资源而阻塞时，对已有资源保持不放。
3. 不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有使用完毕后才释放资源。
4. 循环等待条件:若干线程之间形成一种头尾相接、循环等待资源的关系。

### 10. 如何预防死锁？如何避免死锁？

破坏死锁产生的条件可以预防死锁：

1. **破坏请求与保持条件**：线程可以一次性申请所有的资源。
2. **破坏不剥夺条件**：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
3. **破坏循环等待条件**：按某一顺序申请资源，释放资源则反序释放，破坏循环等待条件。

避免死锁就是在**资源分配**时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

### 11. n个进程每个进程需要m个资源，最少多少个资源不会死锁？

n * (m - 1) + 1

1. **n \* (m - 1)**：这是确保有n个进程中的每个进程都至少获得m-1个资源的资源数量。
2. **+1**：额外的一个资源，保证至少有一个进程可以获得 m 个资源中的最后一个资源，并完成其执行。

### 12. (中高频) 介绍一下几种典型的锁？

------

## IO

### 1. 阻塞和非阻塞区别？同步和异步区别？

在IO调用时，对待操作系统IO就绪状态的不同方式，决定了其是阻塞或非阻塞模式；

在IO执行时，线程或进程是否挂起等待IO执行 决定了其是否为同步或异步IO。

### 2. Java中IO流分为几种？

UNIX系统下， IO模型一共有5种：同步阻塞I/O、同步非阻塞I/O、I/O多路复用、信号驱动I/O和异步I/O。

### 3. (中高频) BIO、NIO、AIO 区别？

**BIO**

同步阻塞I/O 模型中，应用程序对某个socket发起 read 调用后，如果操作无法立即完成，会**一直在单个I/O上阻塞**，**直到内核把数据拷贝到用户空间**。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1712123340362-afe86dbe-e16e-4fe4-9391-6618a9e26935.png)

**NIO**

NIO包含同步非阻塞IO和IO多路复用。

同步非阻塞I/O

指的是：应用程序**通过轮询操作一直向系统发起 read 调用请求**，这个阶段线程是不阻塞的。调用发起成功后，在等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的，直到拷贝完成。

缺点：应用程序不断进行轮询数据是否已经准备好的过程是**十分消耗CPU资源的。**

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1712124221915-4eedd00d-f1bb-4c66-90ec-ef6006aedbc7.png)

**多路复用I/O**

I/O多路复用是一种高效管理I/O流的方式，在单个线程中通过select，poll，epoll多个文件描述符加入到监听列表（比如socket客户端），采用系统调用检查事件描述符上是否有事件发生，在变为可读或者可写的时候会通知应用程序进行适当的处理。



线程首先发起select调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起read调用。
read调用的过程也就是把数据从内核空间拷贝到用户空间时线程还是阻塞的。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1717555394927-5cbcf72f-93ee-47d6-8736-2c14d2543cb1.png)

**AIO**

异步IO是基于事件和回调机制实现的，也就是应用操作之后会直接返回**不会阻塞**，当后台处理完成操作系统会通知相应的线程进行后续的操作。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1717555448670-152a59ec-bf62-457e-be78-325db1764c9d.png)

### 4. (高频) 说一下select、poll、epoll区别？

Linux下有三种提供I/O多路复用的API：select、poll、	

1. select/poll

1. select 的基本原理是将要监控的 Socket 复制到内核空间并放入**文件描述符集合（固定长度的BitMap）**中，内核会遍历这些文件描述符检查是否有网络事件发生，将状态改变的事件**标记**为可读可写事件，再将文件描述符集合拷贝回用户态。因此会进行**2次遍历，2次拷贝**
2. poll 是改进版的 select，但克服了 select 中文件描述符数量的限制，存储结构换成动态数组。

1. epoll

1. epoll在内核里使用epoll_create()创建一个epoll对象，用**红黑树来监控进程中待检测的文件描述符**，把需要监控的socket通过epoll_ctl()加入到内核的红黑树里。减少了用户空间和内核之间大量的数据拷贝
2. epoll使用**事件驱动**机制，内核里维护了一个链表记录就绪事件，事件发生时，内核会将其加入到这个链表中。应用程序会持续调用epoll_wait()检查是否有事件发生，内核只返回有事件发生的socket

**epoll_create**：创建一个 epoll 实例。

**epoll_ctl**：注册、修改或删除文件描述符的监听事件。

**epoll_wait**：等待已注册的文件描述符的事件发生。