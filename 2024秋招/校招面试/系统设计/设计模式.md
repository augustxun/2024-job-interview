## 设计模式概述

### 设计模式的分类了解吗?

1. 创建型： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/建造者/原型模式。
2. 结构型： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。
3. ⾏为型： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式。

## 单例模式

### 1. 什么是单例模式？单例模式的场景？

单例模式：保证**⼀个单例类在任何情况下都只存在⼀个实例**。

**使用场景：**

1. 单例模式为管理和访问全局变量提供了更好的方式；
2. 多个对象共享一个状态和配置，可以所有对象使用同一实例
3. 一个类负责管理一个有限资源池时，使用单例模式确保只有一个实例访问资源

### 2. 饿汉懒汉的区别？

**饿汉式**：

1. 在类加载的**初始化阶段**就创建实例对象，这个过程是线程安全的。

**懒汉式**

1. 懒汉式属于**懒加载机制，**不会预先创建对象，第一次调用才会创建对象；
2. 懒汉式不是线程安全，必须用 synchronized 锁 + 双重检验才能保证线程安全。

### 3. 为什么饿汉式是线程安全的？

在 Java 类加载过程中，初始化阶段会涉及到对静态变量赋值以及静态代码块的执行，因此**饿汉式的实例对象创建在初始化阶段进行**。

**JVM 利用同步机制确保每个类在类加载器中只会被初始化一次**，这也就意味着当有多个线程尝试初始化同一个类时，只有一个线程可以成功，所以初始化过程是线程安全的。因此静态实例只会被创建一次，饿汉式是线程安全的。

### 4. 为什么双重检验锁单例模式要用 volatile 关键字？

*防止指令重排*

指令重排是编译器和处理器的行为，目的是为了优化性能，这就造成实际执行的顺序可能和代码编写顺序不同。对于创建对象实例，一般分为三个步骤：1.分配内存空间；2.对象初始化；3.将引用指向实际内存空间。如果指令重排后，先执行 3 再执行 2，多线程的情况下，别的线程可能会调用 getInstance 方法返回一个尚未完全初始化的对象。

*内存可见性问题*

一个线程创建了单例并写入了 instance 变量，但是结果还没来得及刷新到主内存中，或者其他线程的本地内存的变量副本还没更新，导致判断错误。因此需要用 volatile 保证主存和本地内存同步。

### 为什么枚举类是线程安全的？

1. **单例特性**：每个枚举常量在 JVM 中只有一个实例。
2. **类加载机制**：枚举类型在首次使用时由类加载器加载，并且类加载过程是线程安全的。
3. **不可变性**：枚举常量是不可变的，在创建后不能改变状态。



##  工厂模式

### 什么是工厂模式？工厂模式场景？

1. 如果创建对象的过程比较复杂，包含许多步骤或者依赖其他对象，使用工厂模式可以将创建逻辑隐藏起来，并且对外提供一个接口，通过该接口进行调用。
2. 多个类的创建有特定逻辑时，客户端不需要知道对象具体类型，直接和接口交互。相当于解耦客户端与具体实现
3. 工厂类方便扩展，新的产品类直接在工厂类中去添加