## 应用架构的演变

### 1.单体架构

#### a.非集群模式

单体架构指的是所有的模块、组件都在一个应用中，一个应用对应一个数据库。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716570004174-c889325a-8403-4069-9278-a14cd35c1857.png)

#### b.集群模式

1. 为了提升软件的并发能力，防止应用的单节点故障(一个Tomcat挂了，应用就挂了)，通常会对应用做**集群部署**，集群指的是**复制多个相同的应用**一起工作来提高作业能力。
2. 多个节点将会暴露多个访问地址(ip:port)，那客户端是不知道该访问哪个应用节点的，这个时候我们就需要有一个**请求分发**的功能的组件(负载均衡器)将客户端的请求**相对平均**地分发多个应用节点上，这就是负载均衡。这个做请求分发的组件就是负载均衡器，一般使用Nginx实现负载均衡。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716570138780-7a540015-3e2f-4ab3-8d1a-bea85be4a74c.png)

### 2.分布式和SOA

#### a.分布式架构

**分布式**就是将整体应用**按照业务进行拆分成多个子应用**，多个子应用部署在不同的服务器上，所有的子系统一起工作相互通信、协调才能完成最终的业务流程。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716570543384-4b42290b-bd96-4af5-b489-1dd98c851412.png)

#### b.SOA架构

1. SOA是面向服务的架构,它的思想是每个子应用可以通过网络通信协议向其他子应用提供服务或者消费服务，如用户子系统只需要调用订单子系统的服务层即可完成应用之间的通信；
2. SOA也是分布式架构，我们可以简单的理解为SOA把分布式架构划分成表示层和服务层。服务层中包含了业务逻辑和相关流程，只需要对外暴露服务API即可；表现层负责处理和页面的交互。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716571018906-de4e1e58-138e-445c-9783-6ae1404962e9.png)

#### c.微服务架构

微服务是在SOA架构上的一种发展，简单来说微服务就是把单一的应用进行差分，差分成多个微小服务。每个服务独立运行，每个服务只需要专注一个业务即可，并且每个服务都可以有自己的数据库，多个微服务之间相互配合完成整个系统的业务,这就是微服务。

![img](https://cdn.nlark.com/yuque/0/2024/png/42782944/1716571356775-8255f468-3a9f-4d0c-9df4-b0ef1ad07ea4.png)



------

## 开发原则

### 说说开闭原则？

开闭原则（Open - Closed Principle，简称 OCP）是面向对象设计中的一个重要原则。

开闭原则的定义是：软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。

具体来说，这意味着当您需要对软件系统进行功能扩展时，应该通过添加新的代码来实现，而不是去修改已有的代码。

以下是一些关于开闭原则的优点和例子：

优点：

1. 提高系统的稳定性

- 由于现有代码不会被频繁修改，降低了引入新错误的风险，从而使系统更加稳定可靠。

1. 增强系统的可扩展性

- 新功能可以通过添加新的类、方法或模块来实现，而不会影响到现有的功能，使系统能够轻松应对不断变化的需求。

1. 便于代码的维护和管理

- 开发人员可以清晰地区分哪些部分是稳定的、不需要修改的核心代码，哪些部分是用于扩展和定制的扩展点，使得代码的维护和管理更加容易。

## 参考

https://blog.csdn.net/2301_78485032/article/details/131873242

## 理论&算法&协议

### CAP理论？

CAP理论有三个核心概念，分别是

**Consistency 一致性**：所有节点访问同一份最新的数据副本

**Availability 可用性**：非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。

**Partition Tolerance 分区容错性：**分布式系统出现网络分区的时候，仍然能够对外提供服务。

CAP理论其实是想说明，一个分布式系统不可能同时实现一致性、可用性和分区容忍性。一般要根据应用场景需求在三者之间做出权衡和选择。网络分区正常时，也就是不需要保证P的时候，可以同时保证C和A。当发生网络分区时，只能保证C和A中的一个，即CP或AP。

------

## 微服务

### 微服务划分？

1. 基础设施层

基础设施层通常用于封装对外部资源或服务的访问，如**数据库、缓存系统、消息队列**等。将消息队列相关的代码放在这个层次，可以集中管理外部依赖，并与其他基础设施组件保持一致。

• **放置内容**：

• 消息队列的连接配置类（如 RabbitMQ 的连接工厂配置）。

• 消息队列的客户端初始化和管理类（如生产者、消费者的管理类）。

• 通用的消息操作工具类（如消息发送、接收、重试逻辑等）。

## 分布式锁

### 参考资料

[由浅入深详解四种分布式锁](https://www.cnblogs.com/jeremylai7/p/17332101.html)

### 1. **什么是分布式锁？**

在多线程的环境下，为了保证数据的安全，**锁可以保证在同一时刻只有一个线程可以访问和更新共享的数据。**在单机系统，我们可以使用Java 自带的synchronized 锁或者Lock锁保证线程安全。但是实际的生产环境下，服务器都是分布式集群模式，分布式锁就是**控制分布式系统不同进程访问共享资源**的一种锁的机制。不同进程之间调用需要保持**互斥性**，任意时刻，只有一个客户端能持有锁。

### 2. 分布式锁都有哪些作用？

1. **保证数据的正确性。** 比如：秒杀的时候防止商品超卖，表单重复提交，接口幂等性。
2. **避免重复处理数据。** 比如：避免调度任务在多台机器重复执行；发生缓存击穿时，避免所有并发请求都去查询数据库。

### 3. 分布式锁应该具备哪些条件？

1. **互斥性**：同一时刻只能一个节点服务拥有该锁，当有节点获取锁之后，其他节点无法获取锁；
2. **超时机制**：**不考虑异常的正常情况下**，请求获取锁之后，处理任务完成之后释放锁。但是如果在处理任务**发生服务异常，或者网络异常时**，导致锁无法释放，其他请求都无法获取锁，变成**死锁**。所以设置锁的超时时间。
3. **自动续期**：锁设置了超时机制后，如果持有锁的节点处理任务的时间过长超过了超时时间，就会发生线程未处理完任务锁就被释放了，其他线程就能获取到该锁，导致多个节点同时访问共享资源。对此，开启一个监听线程，定时监听任务，监听任务线程还存活就延长超时时间。当任务完成、或者任务发生异常就不继续延长超时时间。



### 4. 怎么设计一个分布式锁？

**方案一：MySQL**

使用 select xxx for update 通过行级锁锁住，其他事务可以读取数据但不能更新

where条件后要走索引，不然触发**表锁**会降低数据库性能。（原因：索引加速定位，否则全表扫描）

在可重复读隔离级别下，这种锁底层基于间隙锁实现，这是一种悲观锁，会存在线程阻塞问题，别的线程需要等待前面的线程执行完毕才能那个获取锁。



**方案二：Redis实现分布式锁**

Redis实现分布式锁比比较复杂，但是性能更高

SETNX key value EX seconds

如果键不存在时，对键设值，返回1。如果键存在，不做任何操作，返回0。setnx全称是set if not exists

一般还会和EXPIRE组合使用给分布式锁加一个超时时间，避免死锁问题。

可能存在的问题！

1. 提前释放**
   **描述：线程A业务还没有执行完毕锁提前释放了，线程B拿到锁和线程A并发执行，线程A执行完业务后释放锁把线程B的锁释放。

2. 重入问题
   描述：获得锁的线程可以再次进入到相同锁的代码块中，可重入锁的意义在于防止死锁。

3. 不可重试
   描述：目前的分布式只能尝试一次，线程获得锁失败后，应该能再次获得锁。

4. 主从一致性问题
   描述：如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。

   

**解决方案**：

1. 针对锁误删问题，设置过期时间略长于业务执行时间。每个线程**获取锁**时设置一个线程标识，比如UUID作为唯一标识设置成value。在**释放锁**时先判断是不是自己的锁，是再删除，不是就不删除。
2. 即使用了方案1，比锁删锁之间也可能发生卡顿，所以需要用lua脚本保证比锁删锁是原子性的。
3. 即使使用了方案1，还是存在多个线程并发访问临界区的时刻，依旧不安全



**方案三：Redission分布式锁**

Redission是一个在Redis基础上实现的Java驻内存数据网络，不仅提供一系列分布式的Java对象，还提供许多分布式服务，基于Netty通信框架实现。具有四个特性：防死锁、防误删、可重入、自动续期，支持单机模式和集群模式
**可重入性**：

Redisson 实现的分布式锁是可重入的。这意味着同一个线程可以多次获取同一把锁，而不会发生死锁。每次获取锁时，锁的持有计数器会递增，释放锁时计数器递减，直到计数器为零时锁才真正释放。

**自动续期：
**使用看门狗机制，解决了提前释放导致后续误删等一系列问题

**分布式一致性**：

1.**RedLock算法**

RedLock算法核心思想是在多个独立的Redis实例上获取锁，在超过半数的实例上获取锁，就代表获取锁成功。
**2. 延迟释放和看门狗机制**

除了 Redlock 算法，Redisson 还通过以下机制进一步增强锁的可靠性：

**看门狗机制**：Redisson 内置的看门狗机制能够自动续期锁的过期时间，防止因网络延迟或处理时间过长导致的锁过期问题。这减少了锁误释放的风险，进一步确保了一致性。

**延迟释放**：在获取锁时设置一个较长的过期时间，防止在任务未完成前锁被误释放。即使 Redis 主节点在同步锁信息到从节点之前宕机，锁也不会立即失效，而是等待锁的过期时间到达。

**3. 故障恢复机制**

当 Redis 主节点宕机并切换主从时，Redisson 可以通过重试机制来恢复锁状态。在 Redis 恢复正常后，Redisson 会尝试重新获取或恢复之前的锁，避免出现死锁情况。

### 5. 业务逻辑没处理完，锁过期了怎么办？

这其实描述的是一个超时释放的问题

1. 假如正常情况下业务逻辑如果可以在6秒内处理完成，我们应该设置锁过期时间是6秒以上；
2. 获取锁的同时，启动一个异步任务，每当业务执行到三分之一时间，也就是6秒中的第2秒的时候，就自动延长锁过期时间，继续延长到6秒，这样就能保证业务逻辑处理完成之前锁不会过期。

自己手动实现还是比较繁琐的，可以直接利用Redission的看门狗机制

### 6. Redission怎么实现可重入的？

1. **第一次获取锁**
   某个线程第一次获取分布式锁时，会在**Redis**层面创建一个键代表获取锁比如下单业务中的userID（解决重复下单问题），这个键的值是当前线程标识比如ThreadID，表示当前正在持有锁的线程。
2. **重入机制**
   当这个锁**第二次**尝试获取分布式锁时，此时会增加锁的**重入计数器**，不会阻塞业务线程
3. **释放锁
   **当线程调用unlock()释放锁的时候，Redission会减少锁的重入计数器，当减到0的时候彻底释放锁，此时别的线程可以获取该锁。

### 7. 说说Redission的看门狗机制？

在分布式环境中，使用Redis锁时需要为锁设置一个过期时间TTL，以防止客户端崩溃或因其他原因未能正常释放锁。通常，开发者会设置一个固定的锁超时时间，但这可能会带来一些问题：

1. **锁过期问题**：如果任务执行时间超过了锁的TTL，锁会自动失效并可能被其他客户端获取，从而导致多个客户端同时进入临界区，破坏了锁的互斥性。
2. **锁占用时间过长**：如果任务执行时间远短于锁的TTL，则会浪费锁的占用时间，降低系统的并发性能。

看门狗机制可以**动态**管理锁的TTL

1. **默认超时时间：**客户端获取锁时，默认为锁设置一个30s超时时间
2. **自动续期**：
   一旦客户端获取到锁，Redission会启动一个后台任务，每隔10s检查客户端是否仍然持有锁，如果持有锁就将TTL重新设置为30s，这样只要客户端正常工作超时时间就会一直保持在30s
3. **释放锁：
   **客户端完成任务时可以把锁主动释放，看门狗任务停止。
   即使客户端因为崩溃无法释放锁，看门狗检测不到客户端也会让锁自动过期，从而确保不会有死锁。

## 数据一致性

### 分布式场景下怎么保证数据一致性？



## 分布式ID

### 分布式ID的生成策略，有哪些优缺点？



#### 参考资料

[Leaf—美团点评分布式ID生成系统](https://tech.meituan.com/2017/04/21/mt-leaf.html)